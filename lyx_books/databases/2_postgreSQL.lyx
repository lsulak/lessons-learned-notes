#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrbook
\begin_preamble
% DO NOT ALTER THIS PREAMBLE!!!
%
% This preamble is designed to ensure that the manual prints
% out as advertised. If you mess with this preamble,
% parts of the manual may not print out as expected.  If you
% have problems LaTeXing this file, please contact 
% the documentation team
% email: lyx-docs@lists.lyx.org

% the pages of the TOC are numbered roman
% and a PDF-bookmark for the TOC is added

\pagenumbering{roman}
\let\myTOC\tableofcontents
\renewcommand{\tableofcontents}{%
 \pdfbookmark[1]{\contentsname}{}
 \myTOC

 \pagenumbering{arabic}}

% extra space for tables
\newcommand{\extratablespace}[1]{\noalign{\vskip#1}}
\end_preamble
\options bibliography=totoc,index=totoc,BCOR7.5mm,titlepage,captions=tableheading
\use_default_options false
\begin_modules
logicalmkup
theorems-ams
theorems-ams-extended
multicol
shapepar
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "lmodern" "default"
\font_sans "lmss" "default"
\font_typewriter "lmtt" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "PostgreSQL Notes"
\pdf_author "Ladislav Sulak"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "linkcolor=black, citecolor=black, urlcolor=blue, filecolor=blue, pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\notefontcolor #0000ff
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 1
\tocdepth 1
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 1
\math_indentation default
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict true
\end_header

\begin_body

\begin_layout Chapter
PostgreSQL
\end_layout

\begin_layout Itemize
PostgreSQL is truly the world’s most advanced open source database.
 Its manual is very huge!
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/manuals/}}
\end_layout

\end_inset

 It is easily extensible, and lots of extensions already available.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://pgxn.org/}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Safe transactional processing (ACID), quick processing of subsets of data
 - OLTP, and analytical processing - OLAP.
\end_layout

\begin_layout Itemize

\series bold
When not to use PostgreSQL?
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
When more rows are modified than selected (=more updates and deletions,
 maybe use some in-memory database).
\end_layout

\begin_layout Itemize
When you need more advanced partitioning support (maybe use Oracle in that
 case).
 Or maybe Citus.
 So this is not is relevant point.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Update-heavy-use-cases
\end_layout

\begin_deeper
\begin_layout Itemize
PostgreSQL always needs to update all indexes on a table when updating rows
 in the table.
 However, there is a little speculation possible - HOT is useful for the
 special case “where a tuple is repeatedly updated in ways that do not change
 its indexed columns.” In that case, PostgreSQL is able to do the update
 without touching any index if the new row-version can be stored in the
 same page as the previous version.
\end_layout

\begin_layout Itemize
Especially in an update-heavy database, the PostgreSQL implementation of
 index-only scans is pretty much useless.
\end_layout

\end_deeper
\begin_layout Itemize
As a side note, cleaning up a data set after you've imported it into PostgreSQL
 makes the difference clear between the 
\bar under
classic ETL
\bar default
 jobs (extract, transform, load) and the 
\bar under
powerful ELT
\bar default
 jobs (extract, load, transform) where you can transform your data using
 a data processing language: SQL.
\end_layout

\begin_layout Itemize
\begin_inset CommandInset href
LatexCommand href
name "Citus"
target "https://www.citusdata.com/product/"
literal "false"

\end_inset

 transforms Postgres into a distributed horizontally scalable database.
 Under the covers it’s sharding your data, and then has multiple executors
 to route queries accordingly.
 Meanwhile to your application your entire distributed setup appears as
 a single node Postgres database.
 You get all the benefits of sharding without the work.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.citusdata.com/blog/2017/09/15/how-citus-works/}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Instead of creating a distributed database from scratch, the authors created
 Citus, an open source PostgreSQL extension that transparently distributes
 tables and queries in a way that provides horizontal scale, but with all
 the PostgreSQL features that application developers need to be successful.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.citusdata.com/blog/2018/11/30/why-rdbms-is-the-future-of-distribut
ed-databases/}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Many current Citus users initially built their business on a single node
 PostgreSQL server, using many of the advanced capabilities in Postgres,
 and then migrated to Citus with only a few weeks of development effort
 to convert their database schema to distributed and reference tables.
 With any other database, such a migration from a single-node database to
 a distributed database could have taken months—or even years.
\end_layout

\end_deeper
\begin_layout Itemize
The SQL standard defines 4 isolation levels and PostgreSQL implements 3
 of them (
\bar under
dirty reads
\bar default
).
 The isolation level determines which side effects from other transactions
 your transaction is sensitive to.
 You can think of the isolation levels like this:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/transaction-iso.html}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\bar under
Read uncommitted
\bar default
 - PostgreSQL accepts this setting and actually implements 
\bar under
read committed
\bar default
 here, which is compliant with the SQL standard
\end_layout

\begin_layout Itemize

\bar under
Read comitted
\bar default
 - This is the 
\series bold
default one
\series default
 in PostgreSQL (it's good to know, and it is good to know when you should
 change it), and it allows your transaction to see other transaction changes
 as soon as they are committed.
 So, if you run the following query twice in your transaction, but someone
 else added or removed objects from the stock, you will have different counts
 at different points in your transaction: 
\series bold
select count(*) from stock;
\end_layout

\begin_layout Itemize

\bar under
Repeatable read
\bar default
 - In this isolation level, your transaction keeps the same snapshot of
 the whole database for its entire duration, from BEGIN to COMMIT.
 It is very useful to have that for online backups - a straightforward use
 case for this feature.
\end_layout

\begin_layout Itemize

\bar under
Serializable
\bar default
 - This level guarantees that a one-transaction-at-a-time ordering of what
 happens on the server exists with the exact same result as what you are
 obtaining with concurrent activity.
\end_layout

\end_deeper
\begin_layout Itemize
If we want to implement business logic, you have multiple possibilities:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
on the application side
\series default
 - incorrect and inefficient and should be avoided.
 It is preferable to exercise PostgreSQL's ability to execute joins rather
 than play with your network latency.
 Quite often, a few lines of SQL can replace dozens of lines of an imperative
 program.
 Most of the time, the SQL solution is more correct and even faster.
 
\end_layout

\begin_layout Itemize

\series bold
SQL query that is part of application's environment
\series default
 - it depends on concurrency and scalability needs.
\end_layout

\begin_layout Itemize

\series bold
as a server-side stored procedure 
\series default
- using procedural code on server-side allows the developers to build a
 data access API in the database server and to maintain it in a transactional
 way with the database schema - PostgreSQL implements transactions for DDL
 (data definition language and it contains 
\bar under
create
\bar default
, 
\bar under
alter
\bar default
, and 
\bar under
drop
\bar default
 statements) too.
 Another advantage is that you send even less data over the network, as
 the query text is stored on the database server.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Stored procedures
\series default
: server-side functions.
 Those SQL objects store code and then execute it when called.
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
create or replace function get_all_albums
\end_layout

\begin_layout Description
(
\end_layout

\begin_layout Description
in artistid bigint,
\end_layout

\begin_layout Description
out album text,
\end_layout

\begin_layout Description
out duration interval
\end_layout

\begin_layout Description
)
\end_layout

\begin_layout Description
returns setof record
\end_layout

\begin_layout Description
language sql
\end_layout

\begin_layout Description
as $$
\end_layout

\begin_layout Description
select album.title as album,
\end_layout

\begin_layout Description
sum(milliseconds) * interval '1 ms' as duration
\end_layout

\begin_layout Description
from album
\end_layout

\begin_layout Description
join artist using(artistid)
\end_layout

\begin_layout Description
left join track using(albumid)
\end_layout

\begin_layout Description
where artist.artistid = get_all_albums.artistid
\end_layout

\begin_layout Description
group by album
\end_layout

\begin_layout Description
order by album;
\end_layout

\begin_layout Description
$$;
\end_layout

\begin_layout Description
# it is better to have as input parameter artist id instead of artist name
\end_layout

\begin_layout Description
# if we would like to use that function:
\end_layout

\begin_layout Description
select * from get_all_albums(127);
\end_layout

\begin_layout Description
# if you only have the name of the artistt you are interested in, you can
 fetch artist id from a subquery:
\end_layout

\begin_layout Description
select *
\end_layout

\begin_layout Description
from get_all_albums(
\end_layout

\begin_layout Description
(select artistid
\end_layout

\begin_layout Description
from artist
\end_layout

\begin_layout Description
where name = 'Red Hot Chili Peppers')
\end_layout

\begin_layout Description
);
\end_layout

\begin_layout Description
# or, it is possible to use the function in a join (
\bar under
lateral join technique
\bar default
):
\end_layout

\begin_layout Description
select album, duration
\end_layout

\begin_layout Description
from artist,
\end_layout

\begin_layout Description
lateral get_all_albums(artistid)
\end_layout

\begin_layout Description
where artist.name = 'Red Hot Chili Peppers';
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
The main drawback to using 
\bar under
stored procedure
\bar default
 is that you must know when to use procedural code or plain SQL with parameters.
 Procedural code - if you want to use stored procedures, 
\series bold
please always write them in SQL and only switch to PLpgSQL when necessary
\series default
.
 If you want to be efficient, the default should be SQL.
 You could end up with writing business logic on database server in perhaps
 ugly way (yes, there are no round trips, but be careful because of silent
 errors or poorly testable code etc).
\end_layout

\begin_layout Itemize
There are modifiers such as 
\emph on
immutable, stable, volatile, ...
\end_layout

\begin_layout Itemize
The only 100% protection against SQL injections.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://postgres.cz/wiki/Desatero}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Advantages - security (access to tables is restricted), efficiency (no intermedi
ate layers between code and server, reduction of network traffic), re-usability.
\end_layout

\begin_layout Itemize
Disadvantages - debugging is more difficult, limited functionality (because
 of security).
\end_layout

\begin_layout Itemize
For example, using variadic array:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create of replace function avgc(variadic float[])
\end_layout

\begin_layout Standard

\emph on
returns float as $$
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select avg(v) from unnest($1) g(v)
\end_layout

\begin_layout Standard

\emph on
$$ language sql immutable;
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Query plan
\end_layout

\begin_deeper
\begin_layout Itemize
PostgreSQL devises a query plan for each query it receives.
 Choosing the right plan to match the query structure and the properties
 of the data is absolutely critical for good performance, so the system
 includes a complex planner that tries to choose good plans.
 You can use the 
\emph on
EXPLAIN
\emph default
 command to see what query plan the planner creates for any query.
 Plan- reading is an art that requires some experience to master.
 You can see a query plan with:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
explain (analyze, costs, verbose, buffers, format JSON)
\end_layout

\begin_layout Standard

\emph on
<query>;
\end_layout

\end_deeper
\begin_layout Itemize
You can use these tools for visualization: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
url{https://explain.depesz.com/}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
url{http://tatiyants.com/pev/#/about}
\end_layout

\end_inset

 or 
\begin_inset CommandInset href
LatexCommand href
name "pgAdmin"
target "https://www.pgadmin.org/"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize
The vast majority of slow queries found in the wild are still queries that
 return way too many rows to the application, straining the network and
 the servers memory.
 Returning millions of rows to an application that then displays a summary
 in a web browser is far too common.
\end_layout

\begin_layout Itemize
It's important to realize that the cost only reflects things that the planner
 cares about.
 In particular, the cost does not consider the time spent transmitting result
 rows to the client, which could be an important factor in the real elapsed
 time; but the planner ignores it because it cannot change it by altering
 the plan.
\end_layout

\begin_layout Itemize
The rows value is a little tricky because it is not the number of rows processed
 or scanned by the plan node, but rather the number emitted by the node.
 This is often less than the number scanned, as a result of filtering by
 any WHERE-clause conditions that are being applied at the node.
\end_layout

\begin_layout Itemize
The first rule of optimization in SQL, as is true for code in general, is
 to answer the following question: Do I really need to do any of that? The
 very best query optimization technique consists of not having to execute
 the query at all.
\end_layout

\begin_layout Itemize

\series bold
\emph on
EXPLAIN
\series default
\emph default
 command shows execution plan of given query as a tree of steps that are
 needed to obtain the result.
 Each parent node contains sum of estimates of child nodes plus cost estimate
 for the parent node itself.
 The estimate does not consider time spent by sending data to the client
 which can be significant in case of lots of queries with small amount of
 returned data.
 It is the most useful command for query tuning.
 It has several parameters:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
analyze
\emph default
 - show actual run times and other statistics.
 Be careful, with 
\emph on
update 
\emph default
or 
\emph on
delete 
\emph default
statements, actual data will be modified! If it is not intended behavior,
 use it in transaction and then use 
\emph on
rollback.
\end_layout

\begin_layout Itemize

\emph on
verbose - 
\emph default
more information about a plan.
 Adds schema names, column list, and so on.
\end_layout

\begin_layout Itemize

\emph on
buffers - 
\emph default
show shared / local / temp blocks statistics.
 The numbers provided by 
\emph on
buffers
\emph default
 help to identify which parts of the query are the most I/O-intensive.
\end_layout

\begin_layout Itemize

\emph on
format 
\emph default
- output format - text, xml, json, yaml.
\end_layout

\end_deeper
\begin_layout Itemize
The statistics produced by command 
\emph on
analyze 
\emph default
are taken from a randomized sample of the table.
\end_layout

\begin_layout Itemize
How PostgreSQL does come up with these execution plans?
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.citusdata.com/blog/2018/03/06/postgres-planner-and-its-usage-of-st
atistics/}}
\end_layout

\end_inset

 One significant input is to use 
\series bold
\emph on
statistics
\series default
\emph default
 the planner collects.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/static/planner-stats.html}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
These statistics allow the planner to estimate how many rows will be returned
 after executing a certain part of the plan, which then influences the kind
 of scan or join algorithm which will be used.
 They are collected / updated mainly by running 
\emph on
analyze
\emph default
 or 
\emph on
vacuum
\emph default
 (and a few 
\emph on
DDL 
\emph default
commands such as 
\emph on
create index
\emph default
).
\end_layout

\begin_layout Itemize
These statistics are stored by the planner in 
\emph on
pg_class
\emph default
 and in 
\emph on
pg_statistics
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
pg_class 
\emph default
basically stores the total number of entries in each table and index, as
 well as the number of disk blocks occupied by them.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard
create table tbl (
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

col1 int,
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

col2 int
\end_layout

\begin_layout Standard
);
\end_layout

\begin_layout Standard
insert into tbl select i/10000, i/100000
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from generate_series (1,10000000) s(i);
\end_layout

\begin_layout Standard
analyze tbl;
\end_layout

\begin_layout Standard
select *
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from pg_stats
\end_layout

\begin_layout Standard
where tablename = 'tbl'
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and attname = 'col1';
\end_layout

\begin_layout Standard
These single column statistics help the planner in estimating the selectivity
 of your conditions (this is what the planner uses to estimate how many
 rows will be selected by your index scan).
 When multiple conditions are supplied in the query, the planner assumes
 that the columns (or the where clause conditions) are independent of each
 other.
 This doesn't hold true when columns are correlated or dependent on each
 other and that leads the planner to under or over-estimate the number of
 rows which will be returned by these conditions.
\end_layout

\begin_layout Standard
Rather than look at 
\emph on
pg_statistic
\emph default
 directly, it's better to look at its view pg_stats when examining the statistic
s manually.
 
\emph on
pg_stats
\emph default
 is designed to be more easily readable.
 Furthermore, 
\emph on
pg_stats 
\emph default
is readable by all, whereas 
\emph on
pg_statistic
\emph default
 is only readable by a superuser.
 (This prevents unprivileged users from learning something about the contents
 of other people's tables from the statistics.
 The 
\emph on
pg_stats 
\emph default
view is restricted to show only rows about tables that the current user
 can read.)
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
pg_statistics
\emph default
 stores statistics about each column like what percentage of values are
 null for the column, what are the most common values - various histograms,
 and so on.
 Before Postgres 10, there wasn't an easy way to tell the planner to collect
 statistics which capture this relationship between columns.
 But, with Postgres 10, there’s a new feature which is built to solve exactly
 this problem.
 
\emph on
create statistics 
\emph default
can be used to create extended statistics objects which tell the server
 to collect extra statistics about these interesting related columns.
 Entries in 
\emph on
pg_statistic 
\emph default
are updated by the 
\emph on
analyze
\emph default
 and 
\emph on
vacuum analyze
\emph default
 commands, and are always approximate even when freshly updated.
\end_layout

\end_deeper
\begin_layout Itemize
It is possible to control the query planner to some extent by using the
 explicit 
\emph on
join
\emph default
 syntax.
 In a simple join query, such as:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select *
\end_layout

\begin_layout Standard

\emph on
from a, b, c
\end_layout

\begin_layout Standard

\emph on
where a.id = b.id
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and b.ref = c.id;
\end_layout

\begin_layout Standard
the planner is free to join the given tables in any order.
 For example, it could generate a query plan that joins A to B, using the
 
\emph on
where
\emph default
 condition a.id = b.id, and then joins C to this joined table, using the other
 
\emph on
where
\emph default
 condition.
 Or it could join B to C and then join A to that result.
 Or it could join A to C and then join them with B — but that would be inefficie
nt, since the full Cartesian product of A and C would have to be formed,
 there being no applicable condition in the 
\emph on
where
\emph default
 clause to allow optimization of the join.
 (All joins in the PostgreSQL executor happen between two input tables,
 so it's necessary to build up the result in one or another of these fashions.)
 The important point is that these different join possibilities give semanticall
y equivalent results but might have hugely different execution costs.
 Therefore, the planner will explore all of them to try to find the most
 efficient query plan.
\end_layout

\begin_layout Standard
When a query only involves two or three tables, there aren't many join orders
 to worry about.
 But the number of possible join orders grows exponentially as the number
 of tables expands.
 Beyond ten or so input tables it's no longer practical to do an exhaustive
 search of all the possibilities, and even for six or seven tables planning
 might take an annoyingly long time.
 When there are too many input tables, the PostgreSQL planner will switch
 from exhaustive search to a genetic probabilistic search through a limited
 number of possibilities.
 (The switch-over threshold is set by the geqo_threshold run-time parameter.)
 The genetic search takes less time, but it won't necessarily find the best
 possible plan.
\end_layout

\end_deeper
\begin_layout Itemize
For example, 
\emph on
Seq Scan on example_table (cost=0.00..458.00 rows=10000 width=244) 
\emph default
has the following meaning:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.vertabelo.com/blog/technical-articles/understanding-execution-plan
s-in-postgresql}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Estimated 
\series bold
start-up cost
\series default
.
 This is the time expended before the output phase can begin, e.g.
 time to do the sorting in a sort node.
\end_layout

\begin_layout Itemize
Estimated
\series bold
 total cost
\series default
.
 This is stated on the assumption that the plan node is run to completion,
 i.e.
 all available rows are retrieved.
 In practice, a node's parent node might stop short of reading all available
 rows (when using 
\emph on
LIMIT
\emph default
 clause).
\end_layout

\begin_layout Itemize
Estimated 
\series bold
number of
\series default
 
\series bold
rows
\series default
 output by this plan mode.
 Again, the node is assumed to be run to completion.
\end_layout

\begin_layout Itemize
Estimated average 
\series bold
width of rows 
\series default
output by this plan node (in bytes).
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Two important decisions which the optimizer has to make are the choice of
 a scan method, and the choice of a join method.
 In principle, PostgreSQL makes use of 4 different scan methods, and 3 different
 join methods.
\end_layout

\begin_layout Itemize

\series bold
Scan methods:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Sequential Scan 
\emph default
- this scans the entire table to choose the desired rows.
 This is the least effective scanning method because it browses through
 the whole table as stored on disk.
 The optimizer may decide to perform a sequential scan if the condition
 column in the query does not have an index or if the optimizer anticipates
 that the condition will be met by most of the rows in the table.
 Sequential-scan-and-sort frequently beats an index scan for sorting many
 rows, because of the non-sequential disk access required by the index scan.
\end_layout

\begin_layout Itemize

\emph on
Index Scan 
\emph default
- this one traverses the B-tree of an index and looks for matching entries
 in the B-tree leaf nodes.
 It then fetches the data from the table.
 This method is considered for use when there is a suitable index and the
 optimizer predicts to return relatively few rows of the table.
\end_layout

\begin_layout Itemize

\emph on
Index Only Scan
\emph default
 - the advantage of this method is that it avoids the costly table access
 when the database can find the columns in the index itself.
 This approach might be tempting, but please keep in mind that you need
 to create a larger index.
 You should always check whether the performance gain is worth using the
 method.
\end_layout

\begin_layout Itemize

\emph on
Bitmap Index Scan + Recheck + Bitmap Heap Scan
\emph default
 - this is an optimization of a regular Index Scan.
 In a regular Index Scan, the row is accessed immediately after it is found
 in an index.
 In a Bitmap Index Scan the interesting rows are first stored in a bitmap.
 After the index scan is completed, the bitmap is sorted by the physical
 location of a row.
 The rows are then accessed in the order of their physical location.
 The idea is that each disk page is fetched at most once.
 After fetching a disk page, the rows are rechecked for the condition in
 the query.
 The rechecking is required because on occasion – e.g., when the query returns
 a large portion of the index – the Bitmap Index Scan omits to filter rows
 when scanning the index.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Join methods
\end_layout

\begin_deeper
\begin_layout Standard
When there are multiple tables joined in the SQL statement, the optimizer
 needs to pick the right join algorithm.
 The optimizer also decides on the order in which tables in the join are
 accessed.
\end_layout

\begin_layout Itemize

\emph on
Nested Loop
\emph default
, there are 2 versions:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
with inner Sequential Scan:
\emph default
 for each element from the first table it checks every row of the second
 table using the Sequential Scan method.
 If the join condition is fulfilled, the row is returned.
 The method can be very costly and is most often used for small tables.
\end_layout

\begin_layout Itemize

\emph on
with inner Index Scan
\emph default
: it uses an index for the second table instead of the 
\emph on
Sequential Scan
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Hash Join
\emph default
 - starts by preparing a hash table of the smaller table on the join key.
 Each row is stored in the hash table at the location specified by a determinist
ic hash function.
 Next, the larger table is scanned, probing the hash table to find the rows
 which meet the join condition.
 This is a very efficient algorithm, but it requires enough main memory
 to keep the whole hash table.
 Note that the result order might differ from the initial sorting.
\end_layout

\begin_layout Itemize

\emph on
Merge Join
\emph default
 - this is similar to MergeSort algorithm.
 Before the tables are joined, they are both sorted by the join attribute.
 The tables are then scanned in parallel to find matching values.
 Each row is scanned once provided that there are no duplicates in the left
 table.
 This method is preferred for large tables.
 The sorted tables are then passed to the Merge Join algorithm to look for
 parallel rows that match on the Merge Condition.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Indexing strategy
\end_layout

\begin_deeper
\begin_layout Itemize
A PostgreSQL index allows the system to have new options to find the data
 your queries need.
 In the absence of an index, the only option available to your database
 is a sequential scan of your tables.
 The index access methods are meant to be faster than a sequential scan,
 by fetching the data directly where it is.
 Not every query needs to be that fast, the requirements are mostly user
 defined.
 A general system-wide analysis can be achieved using 
\series bold
\emph on
pg_stat_statements
\series default
.
 
\emph default
With this, it is possible to have a list of the most common queries in terms
 of number of times the query is executed, and cumulative time it took to
 execute the query.
 The only way to understand where time is spent in a query is by using 
\series bold
\emph on
explain
\series default
 
\emph default
command and reviewing the 
\emph on
query plan.
\end_layout

\begin_layout Itemize
Indices are data structures, that help read less data, read data in bulk,
 read data presorted.
 However, they come at a cost that they occupy a lot of space on the disk
 (frequently more than data itself), inserts/updates/deletes must update
 indices too, and indices get bloated over time.
\end_layout

\begin_layout Itemize
An index is a way to efficiently retrieve a relatively small number of rows
 from a table.
 It is only useful if the number of rows to be retrieved from a table is
 relatively small (i.e.
 the condition for retrieving rows - the 
\emph on
where 
\emph default
clause - is selective).
 A smaller index takes less storage, is easier to maintain, and is faster
 to scan.
\end_layout

\begin_layout Itemize

\series bold
\bar under
Do not create indices for future use - create them only when needed!
\end_layout

\begin_layout Itemize
Indices are also ordered! Also, they have a special behavior regarding nulls.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create index "my_table_my_column_idx" on "my_table"
\end_layout

\begin_layout Standard

\emph on
using btree ("my_column")
\end_layout

\begin_layout Standard

\emph on
collate "C"
\end_layout

\begin_layout Standard

\emph on
asc
\end_layout

\begin_layout Standard

\emph on
nulls last;
\end_layout

\begin_layout Itemize
For example, for query: 
\emph on
select domain from some_domains_table order by checked as nulls first; 
\emph default
you need this index: 
\emph on
create index concurrently some_domains_table_checked_nulls_first_idx on
 some_domains_table (checked asc nulls first);
\end_layout

\begin_layout Itemize
Another example (indexing an expression) for query 
\emph on
select domain from some_domains_table where lower(domain) = domain.com';
 
\emph default
you need this index: 
\emph on
create index on some_domains_table ((lower(domain)));
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Indexing for constraints
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
primary key
\emph default
, 
\emph on
unique
\emph default
, or 
\emph on
exclusion 
\emph default
(
\emph on
EXCLUDE USING
\emph default
) constraints are handled with the help of a backing index.
 In those three constraint cases, the reason why PostgreSQL needs an index
 is because it allows the system to implement visibility tricks with its
 MVCC implementation.
 If you create one of these constraints, PostgreSQL creates an index for
 you.
\end_layout

\begin_layout Itemize
Internally, data consistency is maintained by using a multiversion model
 (
\series bold
Multiversion Concurrently Control, MVCC
\series default
).
 This means that each SQL statement sees a snapshot of data (a database
 version) as it was some time ago, regardless of the current state of the
 underlying data.
 This prevents statements from viewing inconsistent data produced by concurrent
 transactions performing updates on the same data rows, providing transaction
 isolation for each database session.
 MVCC minimizes lock contention in order to allow for reasonable performance
 in multi-user environments.
\end_layout

\begin_deeper
\begin_layout Itemize
MVCC means that each SQL statement sees a snapshot of data (a database version)
 as it was some time ago, regardless of the current state of the underlying
 data.
 This prevents statements from viewing inconsistent data produced by concurrent
 transactions performing updates on the same data rows, providing transaction
 isolation for each database session.
\end_layout

\begin_layout Itemize
The main advantage of using the MVCC model of concurrency control rather
 than locking is that in MVCC locks acquired for querying (reading) data
 do not conflict with locks acquired for writing data, and so reading never
 blocks writing and writing never blocks reading.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Indexing for queries
\end_layout

\begin_deeper
\begin_layout Itemize
PostgreSQL automatically creates only those indices that are needed for
 the system to behave correctly.
 Any and all other indices are to be defined by the application developers
 when they need a faster access method to some tuples.
\end_layout

\begin_layout Itemize
An index cannot alter the result of a query, it only provides another access
 method to the data, one that is faster than sequential scan in most cases.
 Query semantics and result set don't depend on indices.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Cost of index maintenance
\end_layout

\begin_deeper
\begin_layout Itemize
An index duplicates data in a specialized format made to optimize a certain
 type of searches (this duplicated data set is still ACID compliant: every
 change that is made it to the main tables of your schema must have made
 it to the indices too.
 
\emph on
insert, update, 
\emph default
and 
\emph on
delete
\emph default
 have to maintain the indices, and in transactional way.
\end_layout

\begin_layout Itemize
It is not feasible to index everything in your database.
 Always ask question: Does this query need to run as fast as possible, even
 when it means that you now have to maintain more indices?
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Index types by their range:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Single-column index
\emph default
 - the most common one, B-tree by default, covers one column.
\end_layout

\begin_layout Itemize

\emph on
Multi-column inde
\emph default
x - spans two or more columns, can be used for subset from columns from
 left.
\end_layout

\begin_layout Itemize

\emph on
Partial index 
\emph default
- defined for subset of values of some specific column.
\end_layout

\end_deeper
\begin_layout Itemize
Don't defeat indices
\end_layout

\begin_deeper
\begin_layout Itemize
the following query does not use index on column 
\emph on
a: 
\emph default
...
 where now() > a + interval 30 day;
\end_layout

\begin_layout Itemize
while this query uses index on column 
\emph on
a
\emph default
: ...
 where a > now() - interval 30 day;
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Expression indices
\series default
 - they are useful for queries that match on some function or modification
 of your data.
 Postgres allows you to index the result of that function so that searches
 become as efficient as searching by raw data values.
 For example, 
\emph on
create index users_lower_email on users(lower(email));
\emph default
 can be useful when we have query that uses 
\emph on
where lower(email) = '<lowercased_email>'
\emph default
.
 Or another example, 
\emph on
create index articles_day on articles (date(published_at)); 
\emph default
can be useful when we use query with 
\emph on
where date(articles.published_at) = date('2019-05-26').
\end_layout

\begin_layout Itemize

\series bold
When creating multi-column indices, put highly selective columns first.
 Column order in index definition matters a lot!
\end_layout

\begin_layout Itemize

\series bold
Avoid over-indexing by finding duplicated, unused indices and multi-column
 indices with identical prefix!
\end_layout

\begin_layout Itemize
Make absolutely sure that you are running 
\emph on
vacuum frequently to keep GIN indices working.
\end_layout

\begin_layout Itemize
The Postgres query planner has the ability to 
\series bold
combine and use multiple single-column indices in a multi-column query by
 performing a bitmap index scan.
 
\series default
In general, you can create an index on every column that covers query conditions
 and in most cases Postgres will use them, so make sure to benchmark and
 justify the creation of a multi-column index before you create them.
 As always, indices come with a cost, 
\series bold
and multi-column indices can only optimize the queries that reference the
 columns in the index in the same order, while multiple single column indices
 provide performance improvements to a larger number of queries.
 
\series default
However there are cases where a multi-column index clearly makes sense.
 An index on columns (a, b) can be used by queries containing 
\emph on
where a = x and b = y
\emph default
, or queries using
\emph on
 where a = x o
\emph default
nly, but will not be used by a query using 
\emph on
where
\emph default
 
\emph on
b = y
\emph default
.
 So if this matches the query patterns of your application, the multi-column
 index approach is worth considering.
 Also note that in this case creating an index on 
\emph on
a
\emph default
 alone would be redundant.
\end_layout

\begin_layout Itemize

\series bold
Create indices concurrently! 
\series default
Creating an index on a large dataset can take hours or even days.
 Command 
\emph on
create
\emph default
 
\emph on
index 
\emph default
blocks all writes (not reads!) for the duration of the command.
 Always use 
\emph on
create index concurrently.
 
\emph default
It has several downsides - it takes twice as long, and it if fails, invalid
 index is left behind - you must manually drop it.
\end_layout

\begin_layout Itemize
The previous point - practical example if you add a primary key - what you
 want to do is minimal locking:
\end_layout

\begin_deeper
\begin_layout Itemize
Do not do this:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
alter table items add primary key (id); -- blocks queries for a long time
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Do this instead:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
-- takes a long time, but doesn't block queries
\end_layout

\begin_layout Standard

\emph on
create unique index concurrently items_pk ON items (id);
\end_layout

\begin_layout Standard

\emph on
-- blocks queries, but only very briefly
\end_layout

\begin_layout Standard

\emph on
alter table items add constraint items_pk primary key using index items_pk;
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Index access methods 
\series default
- PostgreSQL implements several of them, each algorithm is well adapted
 to some use cases, which is why it's interesting to maintain several access
 methods.
 
\bar under
By default
\bar default
, command 
\emph on
CREATE INDEX
\emph default
 creates 
\emph on
B-tree
\emph default
 indices, which fit the most common situations.
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
B-tree 
\emph default
-
\emph on
 
\emph default
balanced tree, optimized to handle concurrent read and write operations.

\series bold
 Default type of index, applicable to types that can be sorted.
\end_layout

\begin_layout Itemize

\emph on
Hash
\emph default
 - these can handle only a simple equality comparisons.
 The query planner will consider using a hash index whenever an 
\series bold
indexed column is involved in a comparison using the 
\emph on
=
\emph default
 operator.
 Great for very long strings.
 
\series default
Regarding concurrent applications, deadlock is possible with this index,
 since the locks are held longer than one index operation.
\end_layout

\begin_layout Itemize

\emph on
GiST
\emph default
 - generalized search tree, content-based indexing for 
\series bold
massive amounts of complex content
\series default
 (such as non-scalar data types - geometrical shapes, fts, arrays, or exclusion
 constraints).
 Its implementation in PostgreSQL, it allows support for 2-dimensional data
 types such as the geometry
\series bold
 
\emph on
point
\emph default
 or 
\emph on
ranges
\emph default
 data types
\series default
.
 Those data types don't support a total order, and as a consequence they
 can't be indexed properly in a B-tree index.
\end_layout

\begin_layout Itemize

\emph on
SP-GiST 
\emph default
- spaced partitioned GiST, these indices support non-balanced disk-based
 data structures, such as 
\emph on
quadtrees
\emph default
,
\emph on
 k-d trees
\emph default
, and 
\emph on
radix trees
\emph default
 (tries).
 This is useful when you want to index 2-dimensional data with very different
 densities.
\end_layout

\begin_layout Itemize

\emph on
GIN
\emph default
 - generalized inverted index, designed for handling cases where the
\series bold
 items to be indexed are composite values
\series default
 (
\emph on
jsonb, fts, arrays
\emph default
), and the queries to be handled by the index need to search for element
 values that appear within the composite items.
 For example, items can be documents, and queries could be searching for
 documents containing specific words.
 They are appropriate for data values that contain multiple component values,
 such as arrays.
 An inverted index contains a separate entry for each component value.
 Such index can efficiently handle queries that test for the presence of
 specific component values.
 GIN index is the foundation for PostgreSQL 
\begin_inset CommandInset href
LatexCommand href
name "full text search support"
target "https://www.postgresql.org/docs/current/textsearch-intro.html"
literal "false"

\end_inset

.
 Gin indices support multiple searches for different types of data, including
 intersection, contains, greater than, left, and right.
\end_layout

\begin_layout Itemize

\emph on
BRIN
\emph default
 - block range indices, store summaries about the values stored in consecutive
 physical block ranges of a table.
 It is different from other indices, such as B-tree indices, in that a BRIN
 index does not store information by row number.
 Rather, it stores the statistical information of each data block or each
 consecutive data block.
 The result is that a BRIN index requires much less space than other indices,
 and has very low impact on the process of writing, updating, and deleting
 data.
 Similarly to GiST, SP-GiST, and GIN, BRIN can also support many different
 indexing strategies.
 For data types that have a linear sort order, indexed data corresponds
 to the minimum and maximum values of the values in the column for each
 block range.
 
\series bold
Mostly useful when covering multiple columns.
 So, it suports data that can be sorted by storing min/max values in each
 block.
 
\series default
Taking chronological data for example, BRIN indices would perform very well
 on Equals and Range searches if created based on the time or serial fields.
 Maybe for some time or serial fields.
\end_layout

\begin_layout Itemize

\emph on
RUM
\emph default
 - it is a Postgres Pro Enterprise extension that serves as an enhanced
 version of GIN index.
 It is perfect for full-text search.
\end_layout

\begin_layout Itemize

\emph on
Bitmap
\emph default
 
\emph on
- 
\emph default
index interface of Greenplum, similar ti GIN.
 The difference is that the key of a bitmap index is the value of the index
 column, while the value of a bitmap is BIT rather than list of row numbers
 of a tree.
 When the number of unique values of a field is between 100 and 100,000
 (bitmap is not recommended if the number is beyond this range), if the
 number of records in the table is very big and it does not change frequently
 (or AO table), then using Bitmap indices is probably your best option.
 Similar to B-tree indices, Bitmap indices support equals, greater than,
 smaller than, greater than or equal to, and smaller than or equal to searches.
\end_layout

\begin_layout Itemize

\emph on
Bloom filters
\emph default
 - space-efficient data structures that is used to test whether an element
 is a member of a set.
 If allows fast exclusion of non-matching tuples via signatures whose size
 is determined at index creation.
 This type is most useful when a table has many attributes and queries test
 arbitrary combinations of them.
 Traditional 
\emph on
B-tree
\emph default
 index is faster, but it can require many 
\emph on
B-tree
\emph default
 indices to support all possible queries where one needs only a single 
\emph on
Bloom index
\emph default
.
 It is needed to first 
\emph on
create extension bloom
\emph default
, because this type of index is relatively new.
 Mostly useful when covering multiple columns, when the queries themselves
 are referencing most or all of those columns in equality comparisons.
 This type of index is most useful when a table has many attributes and
 queries test arbitrary combinations of them.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Currently, B-tree indexes offer the best performance for concurrent applications
\series default
; since they also have more features than hash indexes, they are the recommended
 index type for concurrent applications that need to index scalar data.
 When dealing with non-scalar data, B-trees are not useful, and GiST, SP-GiST
 or GIN indexes should be used instead.
\end_layout

\end_deeper
\begin_layout Itemize
Data types 
\emph on
text 
\emph default
and 
\emph on
varchar
\emph default
 are the same in PostgreSQL.
 Type 
\emph on
character varying
\emph default
 is just an alias for 
\emph on
varchar.
 
\emph default
When using 
\emph on
varchar(15)
\emph default
, you are basically telling PostgreSQL to manage a 
\emph on
text
\emph default
 column with a 
\emph on
check 
\emph default
constraint of 15 characters.
\end_layout

\begin_layout Itemize
The non-encoding 
\emph on
SQL_ASCII
\emph default
 accepts any data you throw at it, whereas the 
\emph on
UTF8
\emph default
 encoding (and some others) do check for valid input.
 Never use 
\emph on
SQL_ASCII
\emph default
, as you will not be able to retrieve data in any encoding and will lose
 data because of that! Migrating away from 
\emph on
SQL_ASCII
\emph default
 to a proper encoding such as 
\emph on
UTF8
\emph default
 is possible but lossy and complex.
 For seeing list of databases and their encoding, type to 
\emph on
psql 
\emph default
the command 
\emph on

\backslash
l.
 
\emph default
The
\emph on
 SQL_ASCII 
\emph default
encoding is a trap you need to avoid falling into.
 If it’s possible for you, 
\series bold
use UTF-8 encoding
\series default
 and you’ll have a much simpler life.
\end_layout

\begin_layout Itemize
We may have database encoded in some encoding, and your application doesn't
 know how to handle this encoding.
 You can ask PostgreSQL to convert all data on the fly between the server-side
 encoding and your client-side encoding, thanks to the 
\emph on
client_encoding 
\emph default
setting.
 See what you have with command 
\emph on
show client_encoding; 
\emph default
However, not all combinations of 
\emph on
server encoding
\emph default
 and 
\emph on
client encoding 
\emph default
make sense.
\end_layout

\begin_layout Itemize
PostgreSQL implements multiple data types to handle numbers: 
\emph on
smallint 
\emph default
(signed, 16 bits), 
\emph on
integer 
\emph default
(signed, 32 bit)
\emph on
, bigint 
\emph default
(signed, 64 bit)
\emph on
, numeric 
\emph default
(arbitrary precision numbers)
\emph on
, real 
\emph default
(32 bits, with 6 decimal digits precision)
\emph on
, double precision 
\emph default
(64 bits, with 15 decimal digits precision)
\emph on
.
 
\emph default
The combinatorial explosion of internal operators and support functions
 for comparing numbers is the reason why the PostgreSQL project has chosen
 to have a minimum number of numeric data types: the impacts of adding another
 one is huge in terms of query planning time and internal data structure
 sizing.
 That’s why 
\bar under
there are no unsigned numeric data types in PostgreSQL
\bar default
.
 By the way, never use 
\emph on
real
\emph default
 or 
\emph on
double precision 
\emph default
data types when dealing with money.
 Use either 
\emph on
numeric
\emph default
, which provides arbitrary precision, or an 
\emph on
integer
\emph default
 based representation of the money.
\end_layout

\begin_layout Itemize
Other kinds of numeric data types are 
\emph on
smallserial, serial, 
\emph default
and 
\emph on
bigserial 
\emph default
data types.
 These are actually 
\emph on
pseudo types
\emph default
 - the parser recognize their syntax, but then transforms them into something
 else entirely.
 This:
\emph on
 create table tablename ( colname serial); 
\emph default
is equivalent to:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create sequence tablename_colname_seq;
\end_layout

\begin_layout Standard

\emph on
create table tablename ( colname integer not null default nextval('tablename_col
name_seq') );
\end_layout

\begin_layout Standard

\emph on
alter sequence tablename_colname_seq owned by tablename.colname;
\end_layout

\end_deeper
\begin_layout Itemize
So if you have a 
\emph on
serial
\emph default
 column, its real type is going to be 
\emph on
integer
\emph default
, and as soon as the sequence generates a number that doesn't fit into signed
 4-byte representation, you’re going to have errors.
\end_layout

\begin_layout Itemize
A universally unique identifier (
\emph on
UUID
\emph default
) is a 128-bit number (16 bytes) used to identify information in computer
 systems.
 The term globally unique identifier (
\emph on
GUID
\emph default
) is also used.
 PostgreSQL implements support for 
\emph on
UUID
\emph default
, both for storing and processing them, and also with the 
\series bold
\emph on
uuid-ossp 
\emph default
extension
\series default
, for generating them (
\series bold
or
\series default
 
\series bold
pgcrypto
\series default
).
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create extension "uuid-ossp";
\end_layout

\begin_layout Standard

\emph on
select uuid_generate_v4() from generate_series(1, 10) as t(x);
\end_layout

\begin_layout Itemize
Even if you generate UUIDs from your application, managing them as a proper
 UUID in PostgreSQL is a good idea, as PostgreSQL actually stores the binary
 value of the UUID on 128 bits (or 16 bytes) rather than way more when storing
 the text representation of an UUID: 
\emph on
uuid 'fbb850cc-dd26-4904-96ef-15ad8dfaff07' 
\emph default
is much smaller than 
\emph on
'fbb850cc-dd26-4904-96ef-15ad8dfaff07' 
\emph default
(16 bytes vs 37 bytes).
\end_layout

\begin_layout Itemize
This identifier is a 128-bit quantity that is generated by an algorithm
 chosen to make it very unlikely that the same identifier will be generated
 by anyone else in the known universe using the same algorithm.
 Therefore, for distributed systems, these identifiers provide a better
 uniqueness guarantee than sequence generators, which are only unique within
 a single database.
\end_layout

\end_deeper
\begin_layout Itemize
PostgreSQL can store and process raw binary values as well, and binary columns
 are limited to about 1 GB in size.
 See 
\emph on
bytea 
\emph default
for this purpose.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/datatype-binary.html}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Always use timestamps with time zones! See type 
\emph on
timestamptz
\emph default
, 
\emph on
time with time zone
\emph default
, and 
\emph on
date
\emph default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/datatype-datetime.html}}
\end_layout

\end_inset

.
 A record in database with timezone will not add any additional memory,
 it is the same as without any timezone.
 Internally, PostgreSQL uses 
\emph on
bigint 
\emph default
to store timestamps, and on-disk and in-memory formats are the same with
 or without time zone support
\end_layout

\begin_layout Itemize
Besides the above, PostgreSQL has also 
\emph on
interval 
\emph default
data type, that describes a duration (like a month, or two weeks).
 It is possible to use 
\emph on
intervalstyle
\emph default
 and several values are possible, for example 
\emph on
set intervalstyle to postgres_verbose; 
\emph default
is quite nice for interactive 
\emph on
psql
\emph default
 sessions.
\end_layout

\begin_layout Itemize
It can be difficult to understand when the desired string contains many
 single quotes or backslashes, since each of those must be doubled.
 To allow more readable queries in such situations, PostgreSQL provides
 another way, called 
\series bold
\emph on
dollar quoting
\series default
\emph default
, to write string constants.
 A dollar-quoted string constant consists of a dollar sign ($), an optional
 “tag” of zero or more characters, another dollar sign, an arbitrary sequence
 of characters that makes up the string content, a dollar sign, the same
 tag that began this dollar quote, and a dollar sign:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
$$Dianne's horse$$ 
\emph default
or 
\emph on
$SomeTag$Dianne's horse$SomeTag$
\end_layout

\begin_layout Standard
Notice, that inside the dollar-quoted string, single quotes can be used
 without needing to be escaped.
 Indeed, no characters inside a dollar-quoted string are ever escaped.
\end_layout

\end_deeper
\begin_layout Itemize
PostgreSQL also includes support for network address types: 
\emph on
cidr, inet, 
\emph default
and 
\emph on
macaddr.
\emph default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/datatype-net-types.html}}
\end_layout

\end_inset

 Those are also bundled with indexing support and advanced functions and
 operator support.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/functions-net.html}}
\end_layout

\end_inset

 We can even do an analysis of masks, for example 
\emph on
/24
\emph default
 networks found from our data in database - by using 
\emph on
set_masklen() 
\emph default
function, which allows us to transform an IP address into an arbitrary CIDR
 network address: 
\emph on
set_masklen(given_ip::cidr, 24) - 
\emph default
without 
\emph on
::cidr, 
\emph default
it would not use 
\emph on
.0/24
\emph default
 notation.
 By the way, type cast can be done in two possible ways: 
\emph on
cast ( expression as type)
\emph default
 or, more historical PostgreSQL usage, with 
\emph on
expression::type
\emph default
.
 The first syntax conforms to SQL.
\end_layout

\begin_layout Itemize
Range types - 
\emph on
daterange.
\end_layout

\begin_layout Itemize

\emph on
Arrays
\emph default
 can be used to denormalize data and avoid lookup tables.
 A good rule of thumb for using them that way is that you mostly use the
 
\emph on
array
\emph default
 as a whole, even if you might at times search for elements in the 
\emph on
array
\emph default
.
 Heavier processing is going to be more complex than a lookup table.
 Also, some PostgreSQL array functions show a quadratic behavior: looping
 over arrays elements really is inefficient, so learn to use
\emph on
 unnest()
\emph default
 instead, and filter elements with a 
\emph on
where
\emph default
 clause.
 If you see yourself doing that a lot, it might be a good sign that you
 really needed a lookup table!
\end_layout

\begin_layout Itemize
Comparisons for 
\emph on
arrays:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
in: expression [not] in (value [, ...] )
\end_layout

\begin_layout Itemize

\emph on
any / some / any: expression operator any / some / all (array expression)
\end_layout

\end_deeper
\begin_layout Itemize
Subquery expressions
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
exists: exists (subquery)
\emph default
 - the argument of 
\emph on
exists 
\emph default
is an arbitrary select statement, or subquery.
 The subquery is evaluated to determine whether it returns any rows.
 If it returns at least one row, the result of 
\emph on
exists 
\emph default
is “true”; if the subquery returns no rows, the result of 
\emph on
exists 
\emph default
is “false”.
 It's unwise to assume that the subquery will be evaluated completely.
\end_layout

\begin_layout Itemize

\emph on
in / any / some / all
\emph default
 
\emph on
: 
\emph default
similar as in comparison for arrays, but with subquery.
 I's unwise to assume that the subquery will be evaluated completely.
\end_layout

\end_deeper
\begin_layout Itemize
There is data type 
\emph on
point
\emph default
 which can handle 
\emph on
longtiude 
\emph default
and 
\emph on
latitude
\emph default
 for geographic data.
\end_layout

\begin_layout Itemize
Composite types - PostgreSQL tables are made of tuples with a known type.
 It is possible to manage that type separately from the main table, as in
 the following:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create type rate_t as ( currency text, validity daterange, value numeric
 );
\end_layout

\begin_layout Standard

\emph on
create table rate of rate_t ( exclude using gist (currency with =, validity
 with &&) );
\end_layout

\begin_layout Itemize
The last expression with 
\emph on
gist 
\emph default
is: exclude any tuple where the currency is = to an existing currency in
 our table AND where the 
\emph on
validity
\emph default
 is overlapping with (&&) any existing validity in our table.
 This exclusion constraint is implemented in PostgreSQL using a GiST index.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
XML 
\emph default
- PostgreSQL supports manipulation and storage of XML.
 PostgreSQL extension 
\emph on
plxslt
\emph default
 allows writing stored procedures in 
\emph on
XSLT
\emph default
 transformation language.
 XML processing function and XML indexing is pretty limited in PostgreSQL,
 but it can still be handy in some cases.
\end_layout

\begin_layout Itemize

\emph on
JSON 
\emph default
(
\emph on
json 
\emph default
and 
\emph on
jsonb
\emph default
 data types) - PostgreSQL has built-in support for JSON with a great range
 of processing functions and operators, and complete indexing support.
\end_layout

\begin_deeper
\begin_layout Itemize
PostgreSQL implements a very simple 
\emph on
json 
\emph default
datatype, which is actually 
\emph on
text
\emph default
 under the hood, with a verification that the format is valid 
\emph on
json 
\emph default
input.
\end_layout

\begin_layout Itemize
Later, the community realized that the amount of json processing and advanced
 searching required in PostgreSQL would not be easy or reasonable to implement
 over a 
\emph on
text
\emph default
 datatype, and implemented a binary version of the json datatype, this time
 with a full set of operators and functions to work with.
 This newer version is 
\emph on
jsonb
\emph default
, and is not fully compatible with text-based 
\emph on
json 
\emph default
datatype.
 Type 
\emph on
jsonb 
\emph default
comes from type 
\emph on
hstore
\end_layout

\begin_layout Itemize
The 
\emph on
json
\emph default
 datatype, being a text datatype, stores the data presentation exactly as
 it is sent to PostgreSQL, including whitespace and indentation, and also
 multiple-keys when present (no processing at all is done on the content,
 only form validation).
\end_layout

\begin_layout Itemize
The 
\emph on
jsonb
\emph default
 datatype is an advanced binary storage format with full processing, indexing
 and searching capabilities, and as such preprocesses the json data to an
 internal format, which does include a single value per key; and also isn't
 sensible to extra whitespace or indentation.
\end_layout

\begin_layout Itemize
The data type you probably need and want to use is 
\emph on
jsonb
\emph default
, not the 
\emph on
json
\emph default
 early draft, that is still available for backward compatibility reasons
 only.
\end_layout

\begin_layout Itemize
Two use cases for JSON in PostgreSQL are very commonly found:
\end_layout

\begin_deeper
\begin_layout Itemize
The application needs to manage a set of documents that happen to be formatted
 in JSON.
\end_layout

\begin_layout Itemize
Application designers and developers aren't too sure about the exact set
 of fields needed for a part of the data model, and want this data model
 to be very easily extensible.
\end_layout

\end_deeper
\begin_layout Itemize
It is possible to use 
\emph on
jsonb
\emph default
 as a flexible way to maintain your data model.
 It is possible to then think of PostgreSQL like a schemaless service and
 have a heterogeneous set of documents all in a single relation.
 This trade-off sounds interesting from a model design and maintenance perspecti
ve, but is very costly when it comes to daily queries and application developmen
t: you never really know what you’re going to find out in the 
\emph on
jsonb
\emph default
 columns, so you need to be very careful about your SQL statements as you
 might easily miss rows you wanted to target, for example.
 A good trade-off is to design a model with some static columns are created
 and managed traditionally, and an extra column of 
\emph on
jsonb
\emph default
 type is added for those things you didn't know yet, and that would be used
 only sometimes, maybe for debugging reasons or special cases.
 This works well until the application’s code is querying the 
\emph on
extra
\emph default
 column in every situation because some important data is found only there.
 At this point, it’s worth promoting parts of the 
\emph on
extra
\emph default
 field content into proper PostgreSQL attributes in your relational schema.
\end_layout

\begin_layout Itemize
There are operators and functions defined for this type, for example:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
json -> text
\emph default
, get an attribute
\end_layout

\begin_layout Itemize

\emph on
json -> int
\emph default
, get item of array
\end_layout

\begin_layout Itemize

\emph on
json ->> text,
\emph default
 get an attribute as text
\end_layout

\begin_layout Itemize

\emph on
json ->> int, get item of array as text
\end_layout

\begin_layout Itemize

\emph on
json #> text[], 
\emph default
get attribute determined by path
\end_layout

\begin_layout Itemize

\emph on
json #>> text[]
\emph default
, get attribute determined by path
\emph on
 defined as text
\end_layout

\begin_layout Itemize

\emph on
array_to_json(a) - conversion of array to json
\end_layout

\begin_layout Itemize

\emph on
row_to_json(r) 
\emph default
- conversion of composite type to json
\end_layout

\begin_layout Itemize

\emph on
hstore_to_json(h) -
\emph default
 conversion of hstore type to json, all will be text
\end_layout

\begin_layout Itemize

\emph on
hstore_to_json_loose(h) - 
\emph default
conversion of hstore type to json, with specific data types
\end_layout

\begin_layout Itemize

\emph on
to_json(anyelement) 
\emph default
- conversion of value to a valid json value
\end_layout

\begin_layout Itemize

\emph on
json_each(json) 
\emph default
- transform json to table key / value
\end_layout

\begin_layout Itemize

\emph on
json_each_text(json) 
\emph default
- transform json to table key / value as text
\end_layout

\begin_layout Itemize

\emph on
json_populate_recordset() 
\emph default
- conversion of json to row of specific type
\end_layout

\begin_layout Itemize

\emph on
json_array_elements(json) - 
\emph default
transform 
\emph on
json array to table
\end_layout

\begin_layout Itemize

\emph on
json_build_object() 
\emph default
- creation of tuple with key / value
\end_layout

\begin_layout Itemize

\emph on
json_build_array() 
\emph default
- creation of sequence of values
\end_layout

\begin_layout Itemize

\emph on
json_strip_null(json) 
\emph default
– reduction of null values
\end_layout

\begin_layout Itemize

\emph on
json_pretty(json) 
\emph default
- pretty formatting of json
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\emph on
HStore
\emph default
 - emulates hash array, and you have to do the following: 
\emph on
create extension hstore;
\end_layout

\begin_deeper
\begin_layout Itemize
You can use it as a more effective alternative of EAV.
\end_layout

\begin_layout Itemize
It is supported by GiST and GIN indices.
\end_layout

\begin_layout Itemize
Stored values can be only texts or numbers, which are stored always as text
 format.
\end_layout

\begin_layout Itemize
An example of usage:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create extension hstore;
\end_layout

\begin_layout Standard

\emph on
create table people(personal_id_number numeric primary key, other hstore);
\end_layout

\begin_layout Standard

\emph on
insert into people values(7307150888,'firstname=>laco, surname=>sulak');
\end_layout

\begin_layout Standard

\emph on
create index on people using gist (other);
\end_layout

\end_deeper
\begin_layout Itemize
There are a lot of operators and functions, such as:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
hstore -> text,
\emph default
 for getting a value
\end_layout

\begin_layout Itemize

\emph on
hstore -> text[], 
\emph default
for getting an array of values
\end_layout

\begin_layout Itemize

\emph on
hstore || hstore
\emph default
, for concatenating 2 hstore objects
\end_layout

\begin_layout Itemize

\emph on
hstore ? text
\emph default
, test whether 
\emph on
hstore
\emph default
 object contains key
\end_layout

\begin_layout Itemize

\emph on
hstore ?& text[]
\emph default
, test whether 
\emph on
hstore
\emph default
 object contains all keys
\end_layout

\begin_layout Itemize

\emph on
hstore ?| text[]
\emph default
, test whether 
\emph on
hstore
\emph default
 object contains some key
\end_layout

\begin_layout Itemize

\emph on
hstore @> hstore
\emph default
, test whether left operand contains right operand
\end_layout

\begin_layout Itemize

\emph on
hstore #= hstore
\emph default
, change of keys
\end_layout

\begin_layout Itemize

\emph on
hstore - text
\emph default
, removal of key
\end_layout

\begin_layout Itemize

\emph on
hstore - hstore
\emph default
, difference between two 
\emph on
hstore
\emph default
 objects
\end_layout

\begin_layout Itemize

\emph on
slice(h, text[]) 
\emph default
- returns listed keys
\end_layout

\begin_layout Itemize

\emph on
each(h) - 
\emph default
conversion to table key / value
\end_layout

\begin_layout Itemize

\emph on
hstore_to_matrix(h) 
\emph default
- conversion to 2D array
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\emph on
Enum 
\emph default
- This data type has been added to PostgreSQL in order to make it easier
 to support migrations from MySQL.
 Proper relational design would use a reference table and a foreign key
 instead.
 Using the 
\emph on
enum
\emph default
 PostgreSQL facility is mostly a matter of taste.
 After all, join operations against small reference tables are well supported
 by the PostgreSQL SQL engine.
\end_layout

\begin_deeper
\begin_layout Itemize
It can be created like this: 
\emph on
create type color_t as enum('blue', 'red', 'gray', 'black');
\end_layout

\begin_layout Itemize
However, if you are dealing with a short list of items, the normalized way
 to do that is to handle the 
\emph on
catalog 
\emph default
of accepted values in a dedicated table and reference this table everywhere
 your schema uses that 
\emph on
catalog 
\emph default
of values.
 When using more than 
\emph on
join_collapse_limit 
\emph default
or 
\emph on
from_collapse_limit 
\emph default
relations
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/runtime-config-query.html}}
\end_layout

\end_inset

 in SQL queries, the PostgreSQL optimizer might be defeated, so in some
 schema using 
\emph on
enum 
\emph default
data type rather than a reference table can be beneficial.
\end_layout

\begin_layout Itemize

\emph on
Enum
\emph default
 values have human-readable names but internally they are simple integers.
 They don’t take much storage space.
 To compete with this efficiency using a reference table would require using
 an artificial integer key, rather than a natural primary key of the value
 description.
 Even then the enum does not require any foreign key validation or join
 query overhead.
\end_layout

\begin_layout Itemize

\emph on
Enums
\emph default
 and domains are enforced everywhere, even in stored procedure arguments,
 whereas lookup table values are not.
 Reference table enumerations are enforced with foreign keys, which apply
 only to rows in a table.
\end_layout

\begin_layout Itemize
The enum type defines an automatic (but customizable) order relation:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create type log_level as enum ('notice', 'warning', 'error', 'severe');
\end_layout

\begin_layout Standard

\emph on
select * from log where level >= 'warning';
\end_layout

\end_deeper
\begin_layout Itemize
You can even append new enum values to an existing enum type:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
alter type log_level add value 'fatal';
\end_layout

\begin_layout Standard

\emph on
alter type log_level add value 'debug' before 'notice';
\end_layout

\begin_layout Standard

\emph on
select enum_range(NULL::log_level); -
\begin_inset space ~
\end_inset

- {debug,notice,warning,error,severe,fatal}
\end_layout

\end_deeper
\begin_layout Itemize
Unlike a restriction of values enforced by foreign key, there is no way
 to delete a value from an existing 
\emph on
enum
\emph default
 type.
 The only workarounds are messing with system tables or renaming the 
\emph on
enum
\emph default
, recreating it with the desired values, then altering tables to use the
 replacement 
\emph on
enum
\emph default
.
 Not pretty.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Triggers
\series default
 - activation of certain event in database and a certain function.
 When there is a given event, function is executed.
 There are different types of triggers:
\end_layout

\begin_deeper
\begin_layout Itemize
change of data in database - 
\emph on
before, after
\emph default
 triggers.
 These are the most common ones, used with operations 
\emph on
insert, update,
\emph default
 and
\emph on
 delete.
\end_layout

\begin_layout Itemize
change of data in a view - 
\emph on
instead of 
\emph default
triggers
\end_layout

\begin_layout Itemize
change in system catalog - 
\emph on
event 
\emph default
triggers
\end_layout

\begin_layout Standard
Function, associated with a given trigger, can be executed for each affected
 row (
\emph on
row trigger
\emph default
, where we can use 
\emph on
new 
\emph default
and 
\emph on
old 
\emph default
variable - they contain record after and before a command), or once per
 a statement (
\emph on
statement trigger
\emph default
).
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Procedures 
\series default
- these are new in PostgreSQL 11.
 They are activated with command 
\emph on
call
\emph default
.
 They can modify 
\emph on
input
\emph default
 parameters.
 Also, we can explicitly finish a transaction with 
\emph on
commit 
\emph default
and 
\emph on
rollback
\emph default
 in their implementation.
\end_layout

\begin_layout Itemize

\emph on
Alter table
\end_layout

\begin_deeper
\begin_layout Itemize

\bar under
adding a column
\bar default
 with a default requires updating each row of the table (to store the new
 column value).
 However, if no default is specified, PostgreSQL is able to avoid the physical
 update.
 So if you intend to fill the column with mostly non-default values, it's
 best to add the column with no default, insert the correct values using
 
\emph on
update
\emph default
, and then add any desired default.
 Example: 
\emph on
alter table products add column description text;
\end_layout

\begin_layout Itemize

\bar under
removing a column
\bar default
 - table constraints involving the column are dropped too.
 However, if the column is referenced by a foreign key constraint of another
 table, PostgreSQL will not silently drop that constraint.
 You can authorize dropping everything that depends on the column by adding
 cascade: 
\emph on
alter table products drop column description cascade;
\end_layout

\begin_layout Itemize

\bar under
adding / removing a constraint
\end_layout

\begin_layout Itemize

\bar under
changing a column's data type or its default value
\end_layout

\begin_layout Itemize

\bar under
renaming a column
\bar default
 
\emph on
- alter table products rename column product_no to product_number;
\end_layout

\begin_layout Itemize

\bar under
renaming a table
\bar default
 
\emph on
- alter table products rename to items;
\end_layout

\end_deeper
\begin_layout Itemize
Privileges
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
When an object is created, it is assigned an owner.
 
\series default
The owner is normally the role that executed the creation statement.
 For most kinds of objects, the initial state is that only the owner (or
 a superuser) can do anything with the object.
 
\series bold
To allow other roles to use it, privileges must be granted.
\end_layout

\begin_layout Itemize
There are different kinds of privileges: 
\emph on
select, insert, update, delete, truncate, references, trigger, create, connect,
 temporary, execute, 
\emph default
and
\emph on
 usage
\emph default
.
 The privileges applicable to a particular object vary depending on the
 object's type (table, function, etc).
\end_layout

\begin_layout Itemize

\series bold
The right to modify or destroy an object
\series default
 is always the privilege of the
\series bold
 owner only
\series default
.
\end_layout

\begin_layout Itemize
Using:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
alter 
\emph default
command
\emph on
,
\emph default
 an object can be assigned to a new owner with this.
\end_layout

\begin_layout Itemize

\emph on
grant
\emph default
 command, you can assign different kinds of privileges (
\emph on
update 
\emph default
etc) to different users.
\end_layout

\begin_layout Itemize

\emph on
revoke 
\emph default
command, you can revoke a privilege.
\end_layout

\end_deeper
\begin_layout Itemize
The special “role” name 
\emph on
public 
\emph default
can be used to grant a privilege to every role on the system.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Row security policies
\emph default
 can restrict (apart from privilege system available through 
\emph on
grant
\emph default
, see above) on a per-user basis, which rows can be returned by normal queries
 or inserted, updated, or deleted by data modification commands.
\end_layout

\begin_deeper
\begin_layout Itemize
By default, tables do not have any policies.
 So, if a user has access privileges to a table according to the SQL privilege
 system, all rows within it are equally available for querying or updating.
\end_layout

\begin_layout Itemize
When row security is enabled on a table (with 
\emph on
alter table ...
 enable row level security
\emph default
), all normal access to the table for selecting rows or modifying rows must
 be allowed by a row security policy.
\end_layout

\begin_layout Itemize
Row security policies can be specific to commands, or to roles, or to both.
 A policy can be specified to apply to 
\emph on
all
\emph default
 commands, or to 
\emph on
select, insert, update, 
\emph default
or 
\emph on
delete
\emph default
.
 Multiple roles can be assigned to a given policy, and normal role membership
 and inheritance rules apply.
\end_layout

\begin_layout Itemize
Enabling and disabling row security, as well as adding policies to a table,
 is always the privilege of the table owner only.
\end_layout

\end_deeper
\begin_layout Itemize
Collation
\end_layout

\begin_deeper
\begin_layout Itemize
This is a feature that allows specifying the sort order and character classifica
tion behavior of data per-column, or even per-operation.
\end_layout

\begin_layout Itemize
This alleviates the restriction that the 
\emph on
LC_COLLATE
\emph default
 and 
\emph on
LC_CTYPE
\emph default
 settings of a database 
\series bold
cannot be changed after its creation.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Actually stored data on disk
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.fastware.com/blog/where-and-how-is-your-data-actually-st
ored-on-disk}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
At the basic level, your data is simply stored as a set of files on disk.
\end_layout

\begin_layout Itemize
If you want to see database cluster’s directory, type into 
\emph on
pgsql
\emph default
 the following: 
\emph on
show data_directory;
\end_layout

\begin_layout Itemize
In result, there are a lot of files:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
postgresql.conf 
\emph default
- main server configuration file.
 The important parameters to tune are: 
\emph on
seq_page_cost random_page_cost, 
\emph default
and
\emph on
 default_statistics_target.
\end_layout

\begin_layout Itemize

\emph on
pg_hba.conf 
\emph default
- configuration file for host-based authentication.
\end_layout

\begin_layout Itemize

\emph on
pg_ident.conf 
\emph default
- configuration file for user name mapping.
\end_layout

\begin_layout Itemize
directory named 
\emph on
base
\emph default
 - this is where all the database data for your whole cluster is held.
 You’ll see many directories in the base directory that are just numbers.
 Each one of these numbered directories is a single database in your cluster.
\end_layout

\begin_layout Itemize
and various other files.
\end_layout

\end_deeper
\begin_layout Itemize
If you don't use data encryption, you can see actual data stored in tables,
 for example with 
\emph on
hexdump 
\emph default
utility.
\end_layout

\begin_layout Itemize
An example, let's consider table 
\emph on
test_data
\emph default
 in database 
\emph on
test
\emph default
.
 Firstly you type 
\emph on
show data_directory;
\emph default
 for outputting database files location.
 If you want to see which file on disk actually represents this table, you
 can do the following:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
c test
\end_layout

\begin_layout Standard

\emph on
select pg_relation_filepath('test_data');
\end_layout

\end_deeper
\begin_layout Standard
And let's say that the result is 
\emph on
base/20886/186770
\emph default
, so the file 
\emph on
/database/base/20866/186770
\emph default
 contains the actual data for the table 
\emph on
test_data
\emph default
.
 Now, for seeing actual data, type 
\emph on
hexdump -C /database/master/base/20866/186770.
\end_layout

\begin_layout Itemize
By the way, PostgreSQL by default stores its transaction logs in the
\emph on
 pg_wal 
\emph default
folder of the data directory.
 All changes made to the database are first written to the transaction log
 before anything else can occur.
\end_layout

\begin_layout Itemize
Note: when the 
\emph on
pg_wal 
\emph default
directory fills up and no new files can be created, your database will likely
 shut down and create a state where it can’t be brought up again (you are
 out of disk space)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.fastware.com/blog/how-to-solve-the-problem-if-pg_xlog-is
-full}}
\end_layout

\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Memory components of PostgreSQL instance
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.fastware.com/blog/back-to-basics-with-postgresql-memory-
components}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename fig/postgres_memory.png
	scale 25

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
PostgreSQL instance depicting the memory areas, server background processes,
 and the underlying database files.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Standard
The interesting point to note is all the memory components (which are listed
 above on the figure) which are allocated in the RAM:
\end_layout

\begin_layout Itemize

\emph on
Shared Buffers.

\emph default
 It is always faster to read or write data in memory than on any other media.
 A database server also needs memory for quick access to data, whether it
 is READ or WRITE access.
 In PostgreSQL, this is referred to as "shared buffers" and is controlled
 by the parameter 
\emph on
shared_buffers
\emph default
.
 The amount of RAM required by shared buffers is always locked for the PostgreSQ
L instance during its lifetime.
 The data that is written or modified in this location is called "dirty
 data" and the unit of operation being database blocks (or pages), the modified
 blocks are also called "dirty blocks" or "dirty pages".
 Subsequently, the dirty data is written to disk containing physical files
 to record the data in persistent location and these files are called "data
 files".
\end_layout

\begin_layout Itemize

\emph on
WAL Buffers.

\emph default
 The write ahead log (WAL) buffers are also called "transaction log buffers",
 which is an amount of memory allocation for storing WAL data.
 This WAL data is the metadata information about changes to the actual data,
 and is sufficient to reconstruct actual data during database recovery operation
s.
 The WAL data is written to a set of physical files in persistent location
 called "WAL segments" or "checkpoint segments".
 The WAL buffers memory allocation is controlled by the 
\emph on
wal_buffers
\emph default
 parameter, and it is allocated from the operating system RAM.
 Although this memory area is also accessible by all the background server
 and user processes, it is not part of the shared buffers.
 The WAL buffers are external to the shared buffers and are very small when
 compared to shared buffers.
 The WAL data is first modified (dirtied) in WAL buffers before it is written
 to WAL segments on disk.
 If it is left to default settings, then it is allocated with a size of
 1/16th of the shared buffers
\end_layout

\begin_layout Itemize

\emph on
CLOG Buffers
\emph default
.
 CLOG stands for "commit log", and the CLOG buffers is an area in operating
 system RAM dedicated to hold commit log pages.
 The commit log pages contain log of transaction metadata and differ from
 the WAL data.
 The commit logs have commit status of all transactions and indicate whether
 or not a transaction has been completed (committed).
 There is no specific parameter to control this area of memory.
 This is automatically managed by the database engine in tiny amounts.
 This is a shared memory component.
\end_layout

\begin_layout Itemize

\emph on
Memory for Locks / Lock Space.
 
\emph default
This memory component is to store all heavyweight locks used by the PostgreSQL
 instance.
 These locks are shared across all the background server and user processes
 connecting to the database.
\end_layout

\begin_layout Itemize

\emph on
Vacuum Buffers
\emph default
.
 This is the maximum amount of memory used by each of the autovacuum worker
 processes, and it is controlled by the autovacuum_work_mem database parameter.
 The memory is allocated from the operating system RAM and is also influenced
 by the autovacuum_max_workers database parameter.
\end_layout

\begin_layout Itemize

\emph on
Work Memory
\emph default
.
 This is the amount of memory reserved for either a single sort or hash
 table operation in a query and it is controlled by work_mem database parameter.
 A sort operation could be one of an ORDER BY, DISTINCT or Merge join and
 a hash table operation could be due to a hash-join, hash based aggregation
 or an IN subquery.
\end_layout

\begin_layout Itemize

\emph on
Maintenance Work Memory.
 
\emph default
This is the maximum amount of memory allocation of RAM consumed for maintenance
 operations.
 A maintenance operation could be one of the VACUUM, CREATE INDEX or adding
 a FOREIGN KEY to a table.
 The setting is controlled by the maintenance_work_mem database parameter.
\end_layout

\begin_layout Itemize

\emph on
Temp Buffers.
 
\emph default
A database may have one or more temporary tables, and the data blocks (pages)
 of such temporary tables need a separate allocation of memory to be processed
 in.
 The temp buffers serve this purpose by utilising a portion of RAM, defined
 by the 
\emph on
temp_buffers
\emph default
 parameter.
\end_layout

\begin_layout Subsection
Constraints
\end_layout

\begin_layout Itemize

\series bold
Types
\series default
 
\series bold
of constraints
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Not-null constraints - 
\emph default
in most database designs, the majority of columns should be marked as 
\emph on
not null
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
Unique constraints
\emph default
 - ensure, that the data contained in a column, or a group of columns, is
 unique among all the rows in the table.
 Adding a unique constraint will automatically create a unique B-tree index
 on the column or a group of columns listed in the constraint.
 A unique restriction covering only some rows cannot be written as a unique
 constraint, but it is possible to enforce such a restriction by creating
 a unique partial index.
 Be careful, two null values are never considered equal in this comparison.
 So,
\series bold
 even in the presence of a unique constraint, it is possible to store duplicate
 rows that contain a 
\emph on
null 
\emph default
value in at least one of the constrained columns.
\end_layout

\begin_layout Itemize

\emph on
Primary keys
\emph default
 - uniquely identify a row in a table.
 Cannot be 
\emph on
null
\emph default
 and must be unique.
 Primary key may consist of multiple columns.
\end_layout

\begin_layout Itemize

\emph on
Foreign keys
\emph default
 - they specify that the values in a column(s) must match the values appearing
 in some row from another table.
 They maintain the 
\emph on
referential integrity
\emph default
 between two related tables.
 It makes sure that, for example, if row in table A is related to row in
 table B, then rowA cannot be modified unless rowB is modified too.
 Since a 
\emph on
delete 
\emph default
of a row from the referenced table or an 
\emph on
update
\emph default
 of a referenced column will require a scan of the referencing table for
 rows matching the old value, it is often a good idea to index the referencing
 columns too.
 Because this is not always needed, and there are many choices available
 on how to index, declaration of a foreign key constraint does not automatically
 create an index on the referencing columns.
\end_layout

\begin_layout Itemize

\emph on
Check constraints
\emph default
 - these are the most generic constraint type.
 It allows you to specify that the value in a certain column must satisfy
 a Boolean expression.
 It is satisfied if the check expression evaluates to 
\emph on
true
\emph default
 or 
\emph on
null
\emph default
 value.
\end_layout

\begin_layout Itemize

\emph on
Exclusion constraints 
\emph default
- they ensure that if any two rows are compared on the specified columns
 or expressions using the specified operators, at least one of these operator
 comparisons will return 
\emph on
false
\emph default
 or 
\emph on
null
\emph default
.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create table car_reservation (
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

car integer,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

during tsrange,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

exclude using gist (cat with =, during with &&)
\end_layout

\begin_layout Standard

\emph on
);
\end_layout

\begin_layout Standard
In this case, PostgreSQL will automatically build an index covering both
 columns and it will ensure that the time-range column is not allowed to
 contain overlapping data for the very same car.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Domain constraints
\emph default
 - these are an alias for existing, underlying data type, and they optionally
 include extra restrictions and a default value.
\end_layout

\begin_deeper
\begin_layout Itemize
For example:
\end_layout

\begin_layout Standard

\emph on
create domain human_height as unit check (
\end_layout

\begin_layout Standard

\emph on
'0 ft'::unit < value and value < '10 ft'::unit
\end_layout

\begin_layout Standard

\emph on
);
\end_layout

\begin_layout Standard

\emph on
– – holds a valid height
\end_layout

\begin_layout Standard

\emph on
select '74 in'::human_height;
\end_layout

\begin_layout Standard

\emph on
– – => 1.8796 m
\end_layout

\begin_layout Standard

\emph on
– – but rejects an outlandish one
\end_layout

\begin_layout Standard

\emph on
select '12 ft'::human_height;
\end_layout

\begin_layout Standard

\emph on
ERROR: 23514: value for domain human_height violates check constraint "human_hei
ght_check"
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Itemize
Or, an example on URI, with 
\begin_inset CommandInset href
LatexCommand href
name "pguri"
target "https://github.com/petere/pguri"
literal "false"

\end_inset

 extension:
\end_layout

\begin_layout Standard

\emph on
create extension uri;
\end_layout

\begin_layout Standard

\emph on
create domain http_uri as uri check (
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

uri_scheme(value) is not null
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and uri_scheme(value) in ('http', 'https')
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and uri_host(value) is not null
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and uri_host(value) <> ''
\end_layout

\begin_layout Standard

\emph on
);
\end_layout

\begin_layout Standard

\emph on
-- works great
\end_layout

\begin_layout Standard

\emph on
select 'https://www.foo.com/bar/baz'::http_uri;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
-- forbidden
\end_layout

\begin_layout Standard

\emph on
select 'ftp://www.foo.com/bar/baz'::http_uri;
\end_layout

\begin_layout Itemize
Or, an example with emails:
\end_layout

\begin_layout Standard

\emph on
create domain email as citext check (
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]' +
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

'+@[a-zA-Z0-9](?:[a-zA-Z0-9-]' +
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

'{0,61}[a-zA-Z0-9])?(?:
\backslash
.[a-zA-Z0-9]' +
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

'(?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'
\end_layout

\begin_layout Standard

\emph on
);
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Referential integrity
\end_layout

\begin_deeper
\begin_layout Itemize
As already said, 
\emph on
foreign keys
\emph default
 ensure referential integrity.
 
\series bold
Each
\series default
 
\series bold
referential integrity can be configured to
\series default
:
\end_layout

\begin_deeper
\begin_layout Itemize
block changes
\end_layout

\begin_layout Itemize
cascade changes
\end_layout

\begin_layout Itemize
do nothing until the end of transaction
\end_layout

\begin_layout Itemize
do something else
\end_layout

\end_deeper
\begin_layout Itemize
Make sure to have indices on both sides of referential integrity!
\end_layout

\begin_layout Itemize

\series bold
Referential integrity modifiers
\end_layout

\begin_deeper
\begin_layout Itemize
the following modifiers can be used for both 
\emph on
on delete 
\emph default
and
\emph on
 on update:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
restrict
\emph default
 - immediately prevents modification of a referenced row.
\end_layout

\begin_layout Itemize

\emph on
on action
\emph default
 - default value.
 If any referencing rows still exist when the constraint is checked, an
 error is raised (check can be deferred to the end of transaction).
\end_layout

\begin_layout Itemize

\emph on
cascade
\emph default
 - modifiers referenced rows in case referring row is modified.
\end_layout

\end_deeper
\begin_layout Itemize
The following modifiers can be used only for 
\emph on
on delete:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
set null 
\emph default
- clears the referencing rows values to 
\emph on
null
\end_layout

\begin_layout Itemize

\emph on
set default - 
\emph default
set column default values in referencing rows
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Make sure that you handle NULL values correctly! 
\series default
If referencing columns are not set to 
\emph on
not null
\emph default
, mixture of 
\emph on
null 
\emph default
and valid values satisfies the constraint, unless the constraint is defined
 with 
\emph on
match full 
\emph default
modifier.
\end_layout

\end_deeper
\begin_layout Itemize
When you need to keep around values that are only valid for a period of
 time, consider using the PostgreSQL 
\emph on
range
\emph default
 data types and the 
\emph on
exclusion
\emph default
 
\emph on
constraint
\emph default
 that guarantees no overlapping of values in your data set.
 This is a powerful technique.
\end_layout

\begin_layout Itemize

\series bold
A foreign key constraint
\series default
 must reference a set of keys known to be 
\emph on
unique
\emph default
 in the target table, so PostgreSQL enforce the presence of either a 
\emph on
unique
\emph default
 or a 
\emph on
primary key
\emph default
 constraint on the target table.
 Such a constraint is always implemented in PostgreSQL with a 
\emph on
unique
\emph default
 index.
 PostgreSQL 
\series bold
doesn't create indices at the source side of the
\emph on
 foreign
\emph default
 key
\series default
 
\series bold
constraint
\series default
, though.
 If you need such an index, you have to explicitly create it.
\end_layout

\begin_layout Itemize
Except 
\emph on
primary key, foreign key
\emph default
, and 
\emph on
unique
\emph default
 constraints, there are also other constraints available, such as 
\emph on
not null,
\emph default
 
\emph on
check, domain definition
\emph default
, and 
\emph on
exclude
\emph default
.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create table products ( name text, price numeric check (price > 0), discounted_p
rice numeric, check( discounted_price > 0 and price > discounted_price )
 );
\end_layout

\begin_layout Standard

\emph on
create domain us_postal_code as text
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset

check
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset

(
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

value ~ '^
\backslash
d{5}$'
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

or
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

value ~ '^
\backslash
d{5}=
\backslash
d{4}$'
\end_layout

\begin_layout Standard
);
\end_layout

\end_deeper
\begin_layout Itemize
Exclusion constraints work like a generalized 
\emph on
unique
\emph default
 constraint, with a custom operator choice.
 In the following example, an exchange rate is valid for a period of time
 and we do not allow overlapping periods of validity for a given rate:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create table rates ( currency text, validity daterange, rate numeric, exclude
 using gist (currency with =, validity with &&) );
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
PostgreSQL offers several ways to relax its ACID guarantees and it can be
 compared favorably to most of the NoSQL and NewSQL offerings, at least
 until the concurrency levels can’t be sustained by a single instance.
 
\series default
See description of NoSQL in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:NoSQL"
plural "false"
caps "false"
noprefix "false"

\end_inset

 and NewSQL in Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:NewSQL"
plural "false"
caps "false"
noprefix "false"

\end_inset

.
 While PostgreSQL allows handling schemaless data thanks to its support
 for the 
\emph on
JSON
\emph default
, 
\emph on
XML
\emph default
, 
\emph on
arrays
\emph default
 and
\emph on
 composite 
\emph default
data types, only use this approach when you have zero data quality requirements.
\end_layout

\begin_layout Itemize
PostgreSQL of course, applies a strong durability (D in ACID, see Subsection
 
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Relational-Database-Management"
plural "false"
caps "false"
noprefix "false"

\end_inset

) guarantee to every transaction.
 However, in PostgreSQL it is possible to relax this guarantee for enhanced
 write capacity.
 This can be changed by setting 
\emph on
synchronous_commit
\emph default
 differently for each transaction of the system, or in-flight within a transacti
on.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/wal-async-commit.html}}
\end_layout

\end_inset

 This setting controls the behavior of the server at transaction commit
 time.
\end_layout

\begin_deeper
\begin_layout Itemize
This is helpful for sustaining a really heavy write workloads.
 One way of implementing different 
\emph on
durability 
\emph default
policies in the same application would be to assign a different level of
 guarantee to different users:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create role dbowner with login;
\end_layout

\begin_layout Standard

\emph on
create role app with login;
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
create role critical with login in role app inherit;
\end_layout

\begin_layout Standard

\emph on
create role notsomuch with login in role app inherit;
\end_layout

\begin_layout Standard

\emph on
create role dontcare with login in role app inherit;
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
alter user critical set synchronous_commit to remote_apply;
\end_layout

\begin_layout Standard

\emph on
alter user notsomuch set synchronous_commit to local;
\end_layout

\begin_layout Standard

\emph on
alter user dontcare set synchronous_commit to off;
\end_layout

\end_deeper
\begin_layout Itemize
Use the 
\emph on
dbowner 
\emph default
role for handling your database model and all your 
\emph on
DDL
\emph default
 scripts, and create your database with this role as the owner of it.
 Give enough privileges to the 
\emph on
app
\emph default
 role so that your application can use it to implement all the necessary
 workflows.
 Then the 
\emph on
critical, notsomuch 
\emph default
and 
\emph on
dontcare
\emph default
 roles will have the same set of privileges as the 
\emph on
app
\emph default
 role, and maybe host a different set of settings.
\end_layout

\begin_layout Itemize
Now your application can pick the right connection string or user and obtain
 a stronger guarantee for any data changes made, with the 
\emph on
critical
\emph default
 user, or no durability guarantee with the 
\emph on
dontcare
\emph default
 user.
\end_layout

\begin_layout Itemize
If you need to change the 
\emph on
synchronous_commit
\emph default
 setting in-flight, your application can use the 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "set local"
target "https://www.postgresql.org/docs/current/sql-set.html"
literal "false"

\end_inset


\emph default
 command.
\end_layout

\begin_layout Itemize
It is possible to implement such a policy entirely on the database side
 thanks to PostgreSQL 
\emph on
trigger.
\end_layout

\begin_layout Itemize
Sometimes, even with relaxing the durability guarantees, business requirements
 can't be met with a single server handling all the write traffic.
 Then, it is time to 
\series bold
\emph on
scale out.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Scaling out
\end_layout

\begin_deeper
\begin_layout Itemize
See Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:NoSQL"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for more information about what this is.
 PostgreSQL native scale-out does not exist yet.
 Commercial, open-source extensions, and forks are available that solve
 this problem such as Postgres-BDR from 2ndQuadrant or Citus from citusdata.
 
\series bold
PostgreSQL 10 ships with logical replication support included
\series default
, and this allows for a certain level of scaling-out solutions.
\end_layout

\begin_layout Itemize
If your business manages data from separated areas, say geographically independe
nt units, then it's possible to have each geographical unit served by a
 separate PostgreSQL server.
 Then use logical replication to combine the data set into a single global
 server for a classic setup, or to local copies in each region you operate
 into.
 The application still needs to know where is the data is that it needs
 to access to, so the solution isn't transparent yet.
\end_layout

\begin_layout Itemize
When considering a scaling out solution
\series bold
, always first consider the question of online backups
\series default
: do you still need them, and if so, are they possible to implement? Most
 of the native scale-out systems offer no global transactions, which means
 no isolation from concurrent activity and as a result there is no possibility
 to implement a consistent online backup.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Domain integrity
\end_layout

\begin_deeper
\begin_layout Itemize
The most fundamental constraints.
 They restrict columns to sensible values and prevent data input errors
 and other problems.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://begriffs.com/posts/2017-10-21-sql-domain-integrity.html}}
\end_layout

\end_inset

 It is defined via column's type declaration.
\end_layout

\begin_layout Itemize
You can create your own domain, for example when dealing with gas prices.
 Never go near floating-point representation when money is involved! You
 can use, for example: 
\emph on
create domain gasprice as numeric(6,3); 
\emph default
So, you allow three digits after the decimal, but no more than six digits
 in total.
 So gas prices cannot be greater than 999,999 dollars (or whatever currency).
 There is also 
\emph on
money
\emph default
 data type, but it should be avoided here.
 Regarding currencies, there is an extension called 
\begin_inset CommandInset href
LatexCommand href
name "pg-currency"
target "https://github.com/samv/pg-currency"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize
For various units such as meters, kilograms, bytes, and so on, there is
 a nice extension 
\begin_inset CommandInset href
LatexCommand href
name "postgresql-unit"
target "https://github.com/df7cb/postgresql-unit"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize
For URI, it is better to use 
\begin_inset CommandInset href
LatexCommand href
name "pguri"
target "https://github.com/petere/pguri"
literal "false"

\end_inset

 for example, instead of naive approach with multiple text columns.
 And don't forget about 
\emph on
inet 
\emph default
data type to represent IPv4/IPv6 addresses and optionally subnets.
\end_layout

\begin_layout Itemize
For telephone numbers, there is 
\begin_inset CommandInset href
LatexCommand href
name "libphonenumber"
target "https://github.com/blm768/pg-libphonenumber"
literal "false"

\end_inset

 extension.
\end_layout

\begin_layout Itemize
For storing version number format and for manipulation with them and so
 on, there is an extension 
\begin_inset CommandInset href
LatexCommand href
name "semver"
target "https://github.com/theory/pg-semver"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize
For ISN data, there is 
\emph on
isn't 
\emph default
extension module directly in PostgreSQL.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/isn.html}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
For storing postal address, there is an extension powered by libpostal -
 
\begin_inset CommandInset href
LatexCommand href
name "pgsql-postal"
target "https://github.com/pramsey/pgsql-postal"
literal "false"

\end_inset

 (may consume a large amount of RAM, but it is a big gun), or 
\begin_inset CommandInset href
LatexCommand href
name "parse_address"
target "https://postgis.net/docs/parse_address.html"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize
For storing character insensitive string type, there is 
\emph on

\begin_inset CommandInset href
LatexCommand href
name "citext"
target "https://www.postgresql.org/docs/current/citext.html"
literal "false"

\end_inset


\emph default
 module in PostgreSQL library.
 Essentially, it internally calls lower when comparing values.
 Otherwise, it behaves almost exactly like text.
 It can be used for example for emails with regular expression, for example:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create domain email as citext check (
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

value ~ '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA
-Z0-9])?(?:
\backslash
.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'
\end_layout

\begin_layout Standard

\emph on
);
\end_layout

\end_deeper
\begin_layout Itemize
For having constraint on semi-structured data, such as 
\emph on
jsonb
\emph default
, you can for example specify that a certain key is required (for example
 'name') and the other ones are optional: 
\emph on
create domain named_object as jsonb check (value ? 'name' and jsonb_typeof(value
->'name') = 'string');
\end_layout

\begin_layout Itemize
You can even improve constraint error messages.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create domain positive as numeric check ( value > 0 );
\end_layout

\begin_layout Standard

\emph on
comment on domain positive is 'Number must be positive';
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection

\series bold
Backup
\series default
 
\series bold
and Recovery
\end_layout

\begin_layout Standard
Backup technology can generally be divided into two classes:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://en.wikibooks.org/wiki/PostgreSQL/BackupAndRecovery}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
A cold backup 
\series default
(=offline) is a backup which is taken during a period of time, where no
 database file is open.
 In the case of PostgreSQL this means, that the instance is not running.
\end_layout

\begin_deeper
\begin_layout Itemize
A cold backup is a consistent copy of all files which constitutes the cluster
 with all of its databases.
 To be 
\begin_inset Quotes eld
\end_inset

consistent
\begin_inset Quotes erd
\end_inset

 this copy cannot be taken at an arbitrary point in time.
 There is only one way to create a consistent, useful cold backup: You must
 shut down the PostgreSQL instance 
\emph on
pg_ctl stop
\emph default
, which disconnects all applications from all databases.
\end_layout

\begin_layout Itemize
After the instance is shut down, you can use any operating system utility
 (
\emph on
cp, tar, dd, rsync
\emph default
, ...) to create a copy of all cluster files to a secure location: on the disc
 of a different server, on any backup system at a SAN or the intranet, a
 tape system, ...
 .
\end_layout

\begin_layout Itemize

\series bold
However
\series default
, it is not possible to backup smaller parts of a cluster like a single
 database or table.
 You cannot restore parts of the backup.
 Either you restore everything or nothing.
 After a crash you cannot restore the data to any point in time after the
 last backup generation.
 All changes to the data after this moment gets lost.
 A continuous 7x24 operation mode of any of the databases of this cluster
 is not possible.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
A hot backup
\series default
 (=online) is taken during normal working times, which means, that applications
 can perform read and write actions in parallel to the backup creation.
 Continuous 7x24 operation mode is possible.
 There are 3 different types of hot backups:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Logical Backup 
\series default
- A logical backup is a
\series bold
 consistent copy of the data within a database or some of its parts.
 
\series default
It is created with the utility 
\emph on
pg_dump
\emph default
.
 Although pg_dump may run in parallel to applications (the instance must
 be up), it creates a consistent snapshot as of the time of its start.
 If any data changes some values during the creation of the backup, the
 backup takes the old values whereas the application sees the new ones.
\end_layout

\begin_deeper
\begin_layout Itemize
Small parts of cluster or database may be backup-ed or restored.
\end_layout

\begin_layout Itemize
When you use the text format you can switch from one PostgreSQL version
 to another or from one hardware platform to another.
\end_layout

\begin_layout Itemize

\series bold
However
\series default
, The text format uses much space, but it compresses well.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Physical Backup
\series default
 - A physical backup is an
\series bold
 inconsistent copy of the files of a cluster
\series default
, created with operating system utilities like cp or tar taken at a time
 whereas applications modify data.
\end_layout

\begin_deeper
\begin_layout Itemize
The existence of a physical backup, which is inconsistent by definition
 but contains its WAL files, in combination with this recovery-from-crash
 technique can be used for backup/recovery purposes.
 To implement this, you have to restore the previous taken physical backup
 (including its WAL files).
 When the instance starts again, it uses the described recovery-from-crash
 technique and replays all log records in the WAL files against the database
 files.
 In the exact same way as before, the cluster comes to a consistent state
 and contains all changes up to the point in time when the backup-taken
 has started.
\end_layout

\begin_layout Itemize

\series bold
However
\series default
, physical backup works only on cluster level, not on any finer granularity
 like database or table.
 Without PITR (see below) you will lose all data changes between the time,
 when the physical backup is taken, and the crash.
\end_layout

\begin_layout Itemize
You can do online physical backup of database cluster with 
\emph on
pg_basebackup 
\emph default
command.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://postgres.cz/wiki/Z
\backslash
%C3
\backslash
%A1lohov
\backslash
%C3
\backslash
%A1n
\backslash
%C3
\backslash
%AD_datab
\backslash
%C3
\backslash
%A1ze}}
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Physical Backup plus PITR 
\series default
(Point In Time Recovery) - it is a technique, where you can restore the
 cluster to any point in time between the creation of the backup and the
 crash.
 It takes a physical backup plus all WAL files, which are created since
 the time of taking this backup.
\end_layout

\begin_deeper
\begin_layout Itemize
Recovery with minimal data loss.
\end_layout

\begin_layout Itemize

\series bold
However
\series default
, If your database is very busy and changes a lot of data, many WAL files
 may arise.
 Also, as before, physical backup works only on cluster level, not on any
 finer granularity like database or table.
\end_layout

\end_deeper
\begin_layout Standard
Note: there is a good application written in Python for doing hot online
 backups, called 
\begin_inset CommandInset href
LatexCommand href
name "Barman"
target "https://www.pgbarman.org/index.html"
literal "false"

\end_inset

.
 Also, see 
\begin_inset CommandInset href
LatexCommand href
name "pg_rman"
target "https://github.com/ossc-db/pg_rman"
literal "false"

\end_inset

, which is a simple CLI tool for performing online backups.
\end_layout

\end_deeper
\begin_layout Subsubsection
Reliability and Write-Ahead log
\end_layout

\begin_layout Itemize
One aspect of reliable operation is that all data recorded by a committed
 transaction should be stored in a nonvolatile area that is safe from power
 loss, operating system failure, and hardware failure (except failure of
 the nonvolatile area itself, of course).
 Successfully writing the data to the computer's permanent storage (disk
 drive or equivalent) ordinarily meets this requirement.
\end_layout

\begin_layout Itemize
Each individual record in a WAL file is protected by a CRC-32 (32-bit) check
 that allows us to tell if record contents are correct.
 The CRC value is set when we write each WAL record and checked during crash
 recovery, archive recovery and replication.
\end_layout

\begin_layout Itemize
Write-Ahead Logging (WAL) is a standard method for ensuring data integrity.
\end_layout

\begin_layout Itemize
Briefly, WAL's central concept is that 
\series bold
changes to data files (where tables and indexes reside) must be written
 only after those changes have been logged
\series default
, that is,
\series bold
 after log records describing the changes have been flushed to permanent
 storage.

\series default
 If we follow this procedure, we do not need to flush data pages to disk
 on every transaction commit, because we know that in the event of a crash
 we will be able to recover the database using the log: any changes that
 have not been applied to the data pages can be redone from the log records.
 (This is roll-forward recovery, also known as REDO.)
\end_layout

\begin_layout Itemize
Using WAL results in a significantly reduced number of disk writes, because
 only the log file needs to be flushed to disk to guarantee that a transaction
 is committed, rather than every data file changed by the transaction.
 The log file is written sequentially, and so the cost of syncing the log
 is much less than the cost of flushing the data pages.
 This is especially true for servers handling many small transactions touching
 different parts of the data store.
 Furthermore, when the server is processing many small concurrent transactions,
 one fsync of the log file may suffice to commit many transactions.
\end_layout

\begin_layout Itemize

\series bold
WAL also makes it possible to support on-line backup and point-in-time recovery.
\end_layout

\begin_layout Itemize
WAL is automatically enabled; no action is required from the administrator
 except ensuring that the disk-space requirements for the WAL logs are met,
 and that any necessary tuning is done.
\end_layout

\begin_layout Itemize
WAL records are appended to the WAL logs as each new record is written.
 The insert position is described by a Log Sequence Number (LSN) that is
 a byte offset into the logs, increasing monotonically with each new record.
\end_layout

\begin_layout Itemize

\series bold
Asynchronous commit 
\series default
is an option that allows transactions to complete more quickly, at the cost
 that the most recent transactions may be lost if the database should crash.
 In many applications this is an acceptable trade-off.
\end_layout

\begin_deeper
\begin_layout Itemize
Transaction commit is normally synchronous: the server waits for the transaction
's WAL records to be flushed to permanent storage before returning a success
 indication to the client.
 The client is therefore guaranteed that a transaction reported to be committed
 will be preserved, even in the event of a server crash immediately after.
 However, for short transactions this delay is a major component of the
 total transaction time.
 Selecting asynchronous commit mode means that the server returns success
 as soon as the transaction is logically completed, before the WAL records
 it generated have actually made their way to disk.
 This can provide a significant boost in throughput for small transactions.
\end_layout

\begin_layout Itemize
Asynchronous commit introduces the risk of data loss (not data corruption).
 There is a short time window between the report of transaction completion
 to the client and the time that the transaction is truly committed.
 If the database should crash, it will recover by replaying WAL up to the
 last record that was flushed.
 The database will therefore be restored to a self-consistent state, but
 any transactions that were not yet flushed to disk will not be reflected
 in that state.
\end_layout

\begin_layout Itemize
Certain utility commands, for instance DROP TABLE, are forced to commit
 synchronously regardless of the setting of synchronous_commit.
\end_layout

\begin_layout Itemize
If the database crashes during the risk window between an asynchronous commit
 and the writing of the transaction's WAL records, then changes made during
 that transaction will be lost.
 The duration of the risk window is limited because a background process
 (the “WAL writer”) flushes unwritten WAL records to disk every wal_writer_delay
 milliseconds.
 The actual maximum duration of the risk window is three times wal_writer_delay
 because the WAL writer is designed to favor writing whole pages at a time
 during busy periods.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
fsync
\series default
 is a server-wide setting that will alter the behavior of all transactions.
 If this parameter is on, the PostgreSQL server will try to make sure that
 updates are physically written to disk, by issuing fsync() system calls
 or various equivalent methods (see wal_sync_method).
 This ensures that the database cluster can recover to a consistent state
 after an operating system or hardware crash.
\end_layout

\begin_layout Itemize

\series bold
\emph on
commit_delay
\series default
\emph default
 causes a delay just before a transaction flushes WAL to disk, in the hope
 that a single flush executed by one such transaction can also serve other
 transactions committing at about the same time.
 The setting can be thought of as a way of increasing the time window in
 which transactions can join a group about to participate in a single flush,
 to amortize the cost of the flush among multiple transactions.
\end_layout

\begin_layout Itemize

\series bold
Checkpoints
\series default
 are points in the sequence of transactions at which it is guaranteed that
 the heap and index data files have been updated with all information written
 before that checkpoint.
 At checkpoint time, all dirty data pages are flushed to disk and a special
 checkpoint record is written to the log file.
 (The change records were previously flushed to the WAL files.) In the event
 of a crash, the crash recovery procedure looks at the latest checkpoint
 record to determine the point in the log (known as the redo record) from
 which it should start the REDO operation.
 Any changes made to data files before that point are guaranteed to be already
 on disk.
 Hence, after a checkpoint, log segments preceding the one containing the
 redo record are no longer needed and can be recycled or removed.
 (When WAL archiving is being done, the log segments must be archived before
 being recycled or removed.)
\end_layout

\begin_deeper
\begin_layout Itemize
The server's checkpointer process automatically performs a checkpoint every
 so often.
 A checkpoint is begun every checkpoint_timeout seconds, or if max_wal_size
 is about to be exceeded, whichever comes first.
 The default settings are 5 minutes and 1 GB, respectively.
\end_layout

\begin_layout Itemize
Checkpoints are fairly expensive, first because they require writing out
 all currently dirty buffers, and second because they result in extra subsequent
 WAL traffic.
 It is therefore wise to set the checkpointing parameters high enough so
 that checkpoints don't happen too often.
\end_layout

\end_deeper
\begin_layout Standard

\series bold
WAL files
\end_layout

\begin_layout Itemize
They are files, where changed data values are stored in a binary format.
 WAL files are a specific kind of 
\begin_inset Quotes eld
\end_inset

diff
\begin_inset Quotes erd
\end_inset

 files, always written sequentially.
\end_layout

\begin_layout Itemize
PostgreSQL maintains 
\series bold
Write Ahead Log
\series default
 (WAL) files - primarily for crash-safety purposes.
 They are organized in special structures like trees.
\end_layout

\begin_layout Itemize
Such WAL files contain log records, which reflects all changes made to the
 data and the schema.
 Prior to their transfer to the data files of the database the log records
 are stored in the (sequentially written) WAL file.
\end_layout

\begin_layout Itemize
In the case of a system crash those log records are used to recover the
 cluster to a consistent state during restart.
 The recover process searches the timestamp of the last checkpoint and replays
 all subsequent log records in chronological order against this version
 of the cluster.
 Through that action the cluster gets recovered to a consistent state and
 contains all changes up to the last COMMIT.
\end_layout

\begin_layout Itemize

\series bold
When a client requests a write operation like 
\emph on
update
\emph default
 or 
\emph on
delete
\series default
\emph default
,
\emph on
 
\emph default
the modifications to the data are done in a special sequence and - in some
 parts - asynchronously to the client requests.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
First, data is written and flushed to WAL files.
\end_layout

\begin_layout Itemize

\series bold
Second, it is stored in shared buffers in RAM.
\end_layout

\begin_layout Itemize

\series bold
Finally, it is written from shared buffers to database files.
\end_layout

\begin_layout Itemize
The client doesn't wait until the end of all operations.
 After the first two very fast actions, he is informed that his request
 is completed.
 The third operation is performed asynchronously at an later (or prior)
 point in time.
\end_layout

\end_deeper
\begin_layout Itemize
WAL files are collected in the directory 
\emph on
pg_wal
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
You can define a limit for the total size of all files in the directory:
 
\emph on
max_wal_size
\emph default
.
\end_layout

\begin_layout Itemize
You can define a checkpoint_timeout in seconds.
 No later than this number of seconds, PostgreSQL performs an automatic
 
\emph on
checkpoint
\emph default
 operation.
\end_layout

\begin_layout Itemize
In both cases the shared buffers gets written to disc, a checkpoint-record
 is written to the actual WAL file and all older WAL files are ready to
 be deleted.
\end_layout

\end_deeper
\begin_layout Subsection
Replication
\end_layout

\begin_layout Itemize
There are two types of replication:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Physical replication
\emph default
 - when you want to replicate the whole instance of a given database.
\end_layout

\begin_layout Itemize

\emph on
Logical replication
\emph default
 - when you want to replicate only certain tables.
\end_layout

\end_deeper
\begin_layout Itemize
Directly moving WAL records from one database server to another is typically
 described as 
\series bold
\emph on
log shipping
\series default
\emph default
.
 Continuous archiving can be used to create a
\emph on
 
\series bold
high availability (HA) 
\emph default
cluster configuration with one or more standby servers ready to take over
 operations if the primary server fails.

\series default
 This capability is widely referred to as warm standby or log shipping.
\end_layout

\begin_layout Itemize
The primary and standby server work together to provide this capability,
 though the servers are only loosely coupled.
 The primary server operates in continuous archiving mode, while each standby
 server operates in continuous recovery mode, reading the WAL files from
 the primary.
 No changes to the database tables are required to enable this capability,
 so it offers low administration overhead compared to some other replication
 solutions.
 This configuration also has relatively low performance impact on the primary
 server.
\end_layout

\begin_layout Itemize
WAL files (16MB) can be shipped easily and cheaply over any distance, whether
 it be to an adjacent system, another system at the same site, or another
 system on the far side of the globe.
\end_layout

\begin_layout Itemize

\series bold
It should be noted that log shipping is asynchronous,
\series default
 i.e., the WAL records are shipped after transaction commit.
\end_layout

\begin_layout Itemize
In general, log shipping between servers running different major PostgreSQL
 release levels is not possible.
\end_layout

\begin_layout Itemize

\series bold
Standby Server Operation 
\series default
- In standby mode, the server continuously applies WAL received from the
 master server.
 The standby server can read WAL from a WAL archive 
\series bold
(
\emph on
restore_command
\emph default
)
\series default
 or directly from the master over a TCP connection
\series bold
 (
\emph on
streaming replication
\emph default
)
\series default
.
\end_layout

\begin_layout Itemize

\series bold
Streaming replication
\end_layout

\begin_deeper
\begin_layout Itemize
Allows a standby server to stay more up-to-date than is possible with file-based
 log shipping.
 The standby connects to the primary, which streams WAL records to the standby
 as they're generated, without waiting for the WAL file to be filled.
\end_layout

\begin_layout Itemize
Streaming replication is asynchronous by default, in which case there is
 a small delay between committing a transaction in the primary and the changes
 becoming visible in the standby.
 This delay is however much smaller than with file-based log shipping, typically
 under one second assuming the standby is powerful enough to keep up with
 the load.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
It is very important that the access privileges for replication be set up
 so that only trusted users can read the WAL stream, because it is easy
 to extract privileged information from it.
 
\series default
It is recommended to create a dedicated user account with 
\emph on
REPLICATION
\emph default
 and 
\emph on
LOGIN
\emph default
 privileges for replication.
 While 
\emph on
REPLICATION
\emph default
 privilege gives very high permissions, it does not allow the user to modify
 any data on the primary system.
\end_layout

\begin_layout Itemize

\series bold
Cascading replication
\end_layout

\begin_deeper
\begin_layout Itemize
The cascading replication feature allows a standby server to accept replication
 connections and stream WAL records to other standbys, acting as a relay.
 This can be used to reduce the number of direct connections to the master
 and also to minimize inter-site bandwidth overheads.
\end_layout

\begin_layout Itemize

\series bold
When cascading replication is used, standby servers can also be senders,
 as well as receivers.
\end_layout

\begin_layout Itemize
A standby acting as both a receiver and a sender is known as a cascading
 standby.
 Standbys that are more directly connected to the master are known as upstream
 servers, while those standby servers further away are downstream servers.
\end_layout

\begin_layout Itemize
A cascading standby sends not only WAL records received from the master
 but also those restored from the archive.
 So even if the replication connection in some upstream connection is terminated
, streaming replication continues downstream for as long as new WAL records
 are available.
\end_layout

\begin_layout Itemize
Cascading replication is currently asynchronous.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Synchronous replication
\end_layout

\begin_deeper
\begin_layout Itemize
Synchronous replication offers the ability to confirm that all changes made
 by a transaction have been transferred to one or more synchronous standby
 servers.
\end_layout

\begin_layout Itemize
When requesting synchronous replication, each commit of a write transaction
 will wait until confirmation is received that the commit has been written
 to the write-ahead log on disk of both the primary and standby server.
 The only possibility that data can be lost is if both the primary and the
 standby suffer crashes at the same time.
\end_layout

\begin_layout Itemize
A synchronous standby can be a physical replication standby or a logical
 replication subscriber.
 It can also be any other physical or logical WAL replication stream consumer
 that knows how to send the appropriate feedback messages.
\end_layout

\end_deeper
\begin_layout Subsubsection*
Logical Replication
\end_layout

\begin_layout Itemize
Logical replication is a method of replicating data objects and their changes,
 based upon their replication identity (usually a primary key).
 We use the term logical in contrast to physical replication, which uses
 exact block addresses and byte-by-byte replication.
\end_layout

\begin_layout Itemize
Logical replication uses a 
\emph on
publish
\emph default
 and 
\emph on
subscribe
\emph default
 model with one or more 
\emph on
subscribers
\emph default
 subscribing to one or more 
\emph on
publications
\emph default
 on a 
\emph on
publisher node
\emph default
.
 
\emph on
Subscribers
\emph default
 pull data from the 
\emph on
publications
\emph default
 they subscribe to and may subsequently re-publish data to allow cascading
 replication or more complex configurations.
\end_layout

\begin_layout Itemize
Logical replication of a table typically starts with taking a snapshot of
 the data on the publisher database and copying that to the subscriber.
 Once that is done, the changes on the publisher are sent to the subscriber
 as they occur in real-time.
 The subscriber applies the data in the same order as the publisher so that
 transactional consistency is guaranteed for publications within a single
 subscription.
 This method of data replication is sometimes referred to as 
\series bold
transactional replication
\series default
.
\end_layout

\begin_layout Itemize
The typical use-cases for logical replication are:
\end_layout

\begin_deeper
\begin_layout Itemize
Sending incremental changes in a single database or a subset of a database
 to subscribers as they occur.
\end_layout

\begin_layout Itemize
Firing triggers for individual changes as they arrive on the subscriber.
\end_layout

\begin_layout Itemize
Consolidating multiple databases into a single one (for example for analytical
 purposes).
\end_layout

\begin_layout Itemize
Replicating between different major versions of PostgreSQL.
\end_layout

\begin_layout Itemize
Replicating between PostgreSQL instances on different platforms (for example
 Linux to Windows)
\end_layout

\begin_layout Itemize
Giving access to replicated data to different groups of users.
\end_layout

\begin_layout Itemize
Sharing a subset of the database between multiple databases.
\end_layout

\end_deeper
\begin_layout Itemize
The subscriber database behaves in the same way as any other PostgreSQL
 instance and can be used as a publisher for other databases by defining
 its own publications.
 When the subscriber is treated as read-only by application, there will
 be no conflicts from a single subscription.
 On the other hand, if there are other writes done either by an application
 or by other subscribers to the same set of tables, conflicts can arise.
\end_layout

\begin_layout Itemize
Replication is only possible from base tables to base tables.
 That is, the tables on the publication and on the subscription side must
 be normal tables, not views, materialized views, partition root tables,
 or foreign tables.
\end_layout

\begin_layout Itemize
Logical replication is built with an architecture similar to physical streaming
 replication.
\end_layout

\begin_layout Itemize
The monitoring information about subscription is visible in 
\emph on
pg_stat_subscription
\emph default
.
 This view contains one row for every subscription worker.
\end_layout

\begin_layout Itemize

\series bold
Security
\end_layout

\begin_deeper
\begin_layout Itemize
The role used for the replication connection must have the 
\emph on
REPLICATION
\emph default
 attribute (or be a superuser).
 Access for the role must be configured in 
\emph on
pg_hba.conf
\emph default
 and it must have the 
\emph on
LOGIN
\emph default
 attribute.
\end_layout

\begin_layout Itemize
To create a subscription, the user must be a superuser.
\end_layout

\begin_layout Itemize
To create a publication, the user must have the 
\emph on
CREATE
\emph default
 privilege in the database.
\end_layout

\begin_layout Itemize
To add tables to a publication, the user must have ownership rights on the
 table.
\end_layout

\begin_layout Itemize
Privileges are only checked once at the start of a replication connection.
 They are not re-checked as each change record is read from the publisher,
 nor are they re-checked for each change when applied.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Publication
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
A publication can be defined on any physical replication master.
 
\series default
The node where a publication is defined is referred to as publisher.
 A publication is a set of changes generated from a table or a group of
 tables, and might also be described as a change set or replication set.
 Each publication exists in only one database.
\end_layout

\begin_layout Itemize
Publications can choose to limit the changes they produce to any combination
 of INSERT, UPDATE, DELETE, and TRUNCATE, similar to how triggers are fired
 by particular event types.
 By default, all operation types are replicated.
\end_layout

\begin_layout Itemize
A published table must have a “
\series bold
\emph on
replica identity
\series default
\emph default
” configured in order to be able to replicate 
\emph on
update
\emph default
 and 
\emph on
delete
\emph default
 operations, so that appropriate rows to update or delete can be identified
 on the subscriber side.
 By default, this is the primary key, if there is one.
 Another unique index (with certain additional requirements) can also be
 set to be the replica identity.
 If the table does not have any suitable key, then it can be set to replica
 identity “full”, which means the entire row becomes the key.
 This, however, is very inefficient and should only be used as a fallback
 if no other solution is possible.
 
\emph on
insert 
\emph default
operations can proceed regardless of any replica identity.
\end_layout

\begin_layout Itemize
Every publication can have multiple subscribers.
 A publication is created using the 
\emph on
create publication
\emph default
 command and may later be altered or dropped using corresponding commands.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Subscription
\end_layout

\begin_deeper
\begin_layout Itemize
A subscription is the downstream side of logical replication.
 The node where a subscription is defined is referred to as the subscriber.
 A subscription defines the connection to another database and set of publicatio
ns (one or more) to which it wants to subscribe.
\end_layout

\begin_layout Itemize
The subscriber database behaves in the same way as any other PostgreSQL
 instance and can be used as a publisher for other databases by defining
 its own publications.
\end_layout

\begin_layout Itemize
Each subscription will receive changes via one so called 
\series bold
\emph on
replication slot
\series default
.

\emph default
 Normally, the remote replication slot is created automatically when the
 subscription is created using 
\emph on
create subscription
\emph default
 and it is dropped automatically when the subscription is dropped using
 
\emph on
drop
\emph default
 
\emph on
subscription
\emph default
.
 Replication slots provide an automated way to ensure that the master does
 not remove WAL segments until they have been received by all standbys,
 and that the master does not remove rows which could cause a recovery conflict
 even when the standby is disconnected.
 Existing replication slots and their state can be seen in the 
\emph on
pg_replication_slots 
\emph default
view.
\end_layout

\begin_layout Itemize
Subscriptions are dumped by
\emph on
 pg_dump 
\emph default
if the current user is a superuser.
 Otherwise a warning is written and subscriptions are skipped, because non-super
users cannot read all subscription information from the
\emph on
 pg_subscription
\emph default
 catalog.
\end_layout

\begin_layout Itemize
The schema definitions are not replicated, and the published tables must
 exist on the subscriber.
 Only regular tables may be the target of replication.
 For example, you can't replicate to a view.
 The tables are matched between the publisher and the subscriber using the
 fully qualified table name.
 Replication to differently-named tables on the subscriber is not supported.
 Columns of a table are also matched by name.
 A different order of columns in the target table is allowed, but the column
 types have to match.
 The target table can have additional columns not provided by the published
 table.
 Those will be filled with their default values.
\end_layout

\end_deeper
\begin_layout Itemize
Quick setup, for starting the replication process, which synchronizes the
 initial table contents of the tables 
\emph on
users
\emph default
 and 
\emph on
departments
\emph default
 and then starts replicating incremental changes to those tables:
\end_layout

\begin_deeper
\begin_layout Itemize
In 
\emph on
postgresql.conf:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
wal_level = logical
\end_layout

\end_deeper
\begin_layout Itemize
In 
\emph on
pg_hba.conf 
\emph default
(for example)
\emph on
:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
host all repuser 0.0.0.0/0 md5
\end_layout

\end_deeper
\begin_layout Itemize
On the publisher database:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create publication mypub for table users, departments;
\end_layout

\end_deeper
\begin_layout Itemize
On the subscriber database:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create subscription mysub connection 'dbname=foo host=bar user=repuser'
 publication mypub;
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
JIT Compilation
\end_layout

\begin_layout Itemize
Just-in-Time (JIT) compilation is the process of turning some form of interprete
d program evaluation into a native program, and doing so at run time.
 For example, instead of using general-purpose code that can evaluate arbitrary
 SQL expressions to evaluate a particular SQL predicate like 
\emph on
where
\emph default
 a.col = 3, it is possible to generate a function that is specific to that
 expression and can be natively executed by the CPU, yielding a speedup.
\end_layout

\begin_layout Itemize
PostgreSQL has builtin support to perform JIT compilation using 
\begin_inset CommandInset href
LatexCommand href
name "LLVM"
target "https://llvm.org/"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize
Currently PostgreSQL's JIT implementation has support for:
\end_layout

\begin_deeper
\begin_layout Itemize
accelerating expression evaluation - 
\emph on
where 
\emph default
clauses, target lists, aggregates and projections.
\end_layout

\begin_layout Itemize
tuple deforming - process of transforming an on-disk tuple into its in-memory
 representation.
\end_layout

\end_deeper
\begin_layout Itemize
JIT compilation is beneficial primarily for long-running CPU-bound queries.
 Frequently these will be analytical queries.
 For short queries the added overhead of performing JIT compilation will
 often be higher than the time it can save.
\end_layout

\begin_layout Itemize

\emph on
explain
\emph default
 can be used to see whether JIT is used or not.
\end_layout

\begin_layout Subsection
History Tables and Audit Trails
\end_layout

\begin_layout Itemize
If we would like to keep a full history of changes available for audit trails,
 we can create some history table.
 This new table would not be a denormalized version of the main table, but
 rather another version of the model entirely.
\end_layout

\begin_layout Itemize
In PostgreSQL, we can take an advantage of 
\emph on
jsonb
\emph default
 data type:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create schema if not exists archive;
\end_layout

\begin_layout Standard

\emph on
create type archive.action_t as enum('insert', 'update', 'delete');
\end_layout

\begin_layout Standard

\emph on
create table archive.older_versions ( table_name text, date timestamptz default
 now(), action archive.action_t, data jsonb );
\end_layout

\end_deeper
\begin_layout Itemize
With PostgreSQL extension 
\begin_inset CommandInset href
LatexCommand href
name "hstore"
target "https://www.postgresql.org/docs/current/hstore.html"
literal "false"

\end_inset

 for computing 
\emph on
diff
\emph default
 between versions thanks to the support for the 
\emph on
- 
\emph default
operator on this data type.
\end_layout

\begin_layout Itemize
Recording the data as 
\emph on
jsonb
\emph default
 or 
\emph on
hstore
\emph default
 in the history table allows for having a single table for a whole application.
 More importantly, it means that dealing with an application life cycle
 where the database model evolves is allowed as well as dealing with different
 versions of objects into the same archive.
\end_layout

\begin_layout Subsection
Partitioning
\begin_inset CommandInset label
LatexCommand label
name "subsec:Partitioning"

\end_inset


\end_layout

\begin_layout Itemize
Partitioning refers to splitting a table with too many rows into a set of
 tables each containing a part of those rows (multiple disjunctive physical
 subsets).
 Several kinds of partitioning are available, such as 
\emph on
list
\emph default
 or 
\emph on
range
\emph default
 partitioning.
 So, partitioning refers to splitting what is logically one large table
 into smaller physical pieces.
 Partitioning can provide several benefits:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Query performance
\series default
 can be improved dramatically in certain situations, particularly when most
 of the heavily accessed rows of the table are in a single partition or
 a small number of partitions.
 Faster lookups.
 The partitioning substitutes for leading columns of indices, reducing index
 size and making it more likely that the heavily-used parts of the indices
 fit in memory.
\end_layout

\begin_layout Itemize
When queries or updates access a large percentage of a single partition,
 performance can be improved by taking advantage of sequential scan of that
 partition instead of using an index and random access reads scattered across
 the whole table.
\end_layout

\begin_layout Itemize

\series bold
Bulk loads and deletes
\series default
 can be accomplished by adding or removing partitions, if that requirement
 is planned into the partitioning design.
 Doing 
\emph on
alter table detach partition
\emph default
 or dropping an individual partition using 
\emph on
drop table 
\emph default
is far faster than a bulk operation.
 These commands also entirely avoid the 
\emph on
vacuum 
\emph default
overhead caused by a bulk 
\emph on
delete
\emph default
.
\end_layout

\begin_layout Itemize

\series bold
Seldom-used data can be migrated to cheaper and slower storage media.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
The benefits will normally be worthwhile only when a table would otherwise
 be very large.

\series default
 The exact point at which a table will benefit from partitioning depends
 on the application, although 
\series bold
a rule of thumb is that the size of the table should exceed the physical
 memory of the database server.
\end_layout

\begin_layout Itemize
From PostgreSQL 11, we can create indices on partition tables.
 Automatically, an index is created on all partitions (recursively on tables
 that are used as partition).
\end_layout

\begin_layout Itemize
Since primary keys are not supported on partitioned tables, foreign keys
 referencing partitioned tables are not supported, nor are foreign key reference
s from a partitioned table to some other table.
\end_layout

\begin_layout Itemize
Using the 
\emph on
on conflict 
\emph default
clause with partitioned tables will cause an error, because 
\emph on
unique
\emph default
 or 
\emph on
exclusion constraints
\emph default
 can only be created on individual partitions.
 
\series bold
There is no support for enforcing uniqueness
\series default
 (or an 
\emph on
exclusion constraint
\emph default
) 
\series bold
across an entire partitioning hierarchy.
\end_layout

\begin_layout Itemize
An 
\emph on
update
\emph default
 that causes a row to move from one partition to another fails, because
 the new value of the row fails to satisfy the implicit partition constraint
 of the original partition.
\end_layout

\begin_layout Itemize
Row triggers, if necessary, must be defined on individual partitions, not
 the partitioned table.
\end_layout

\begin_layout Itemize
So, when using partitioning in PostgreSQL 10, we lose the ability to reach
 even 
\emph on
1NF
\emph default
 by the lack of 
\emph on
covering
\emph default
 primary key.
 Then we lose the ability to maintain a reference to the partitioned table
 with a 
\emph on
foreign key
\emph default
.
\end_layout

\begin_layout Itemize
Before partitioning any table in PostgreSQL, as with any other denormalization
 technique, please do your homework: check that it’s really not possible
 to sustain the application’s workload with a normalized model.
\end_layout

\begin_layout Itemize

\emph on
Partition 
\emph default
in PostgreSQL is basically a derived table with defined restriction.
 This restriction should be time invariant - so, for example, we should
 not try to try to do the partition for the last 30 days.
 Deriving tables is a very special thing of PostgreSQL, and it is basically
 a partial support for OOP - parenting relation (table) contains some attributes
, and child relation contains all these, plus it may contain some extra
 attributes.
 Also, parent contain all the data that its children.
\end_layout

\begin_deeper
\begin_layout Itemize
A very simple example:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
create table people(firstname text, surname text);
\end_layout

\begin_layout Itemize

\emph on
create table students(field text) inherits (people);
\end_layout

\begin_layout Itemize

\emph on
create table employees(department text) inherits(people);
\end_layout

\end_deeper
\begin_layout Itemize
Another example, with some restriction:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create table purchase_order(imported date, cost numeric(12,2));
\end_layout

\begin_layout Standard

\emph on
create table purchase_order_2012 (check(extract(year from imported) = 2012))
 inherits (purchase_order);
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
The number of partitions is not limited, but it should not be more than
 100 partitions of a single table.
 There could be a big problem with memory requirements of PostgreSQL optimizer.
\end_layout

\begin_layout Itemize
It is very important to use 
\emph on
explain
\emph default
 command and to check, whether your query is written in a way that 
\emph on
planner 
\emph default
can detect only relevant 
\emph on
partitions
\emph default
.
 For example, when you have a 
\emph on
where
\emph default
 condition in a given query, there are probably some partitions that does
 not fit a given restriction, and thus would be never used for a specific
 query.
\end_layout

\begin_layout Subsection
Isolation and Locking
\end_layout

\begin_layout Itemize
The main feature of any database system is its implementation of concurrency
 and full respect of the system’s constraints and properties when multiple
 transactions are modifying the state of the system at the same time.
 PostgreSQL is fully ACID compliant and implements transactions isolation
 so that your application’s concurrency can be dealt with gracefully.
\end_layout

\begin_layout Itemize
Given the ACID properties, a transaction must be 
\bar under
isolated
\bar default
 from other concurrent transactions running in the system.
 It is possible to choose the level of isolation from the concurrent activity,
 depending on your use case.
\end_layout

\begin_layout Itemize
A simple use case for isolation is 
\emph on
online backups
\emph default
.
 The backup application for PostgreSQL is
\emph on
 pg_dump
\emph default
, and the role of this application is to take a snapshot of your whole database
 and export it to a backup file.
 This requires that
\emph on
 pg_dump
\emph default
 reads are completely isolated from any concurrent write activity in the
 system, and this is obtained with the isolation level
\emph on
 serializable
\emph default
 as described next.
\end_layout

\begin_layout Itemize

\series bold
Transaction isolation
\series default
 - SQL standard defines 4 levels of transaction isolation.
 The most strict is 
\series bold
\emph on
Serializable
\series default
 
\emph default
- any concurrent execution of a set of
\emph on
 Serializable 
\emph default
transactions is guaranteed to produce the same effect as running them 
\series bold
one at a time in some order
\series default
.
 The other 3 levels are defined in terms of phenomena, resulting from interactio
n between concurrent transaction, which must not occur at each level.
 None of these phenomena are possible at 
\emph on
Serializable
\emph default
 level.
 The following phenomena are prohibited at various levels:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Dirty read 
\emph default
- a transaction reads data written by a concurrent uncommitted transaction.
\end_layout

\begin_layout Itemize

\emph on
Nonrepeatable read -
\emph default
 a transaction re-reads data it has previously read and finds that data
 has been modified by another transaction (that committed since the initial
 read).
\end_layout

\begin_layout Itemize

\emph on
Phantom read 
\emph default
- a transaction re-executes a query returning a set of rows that satisfy
 a search condition and finds that the set of rows satisfying the condition
 has changed due to another recently committed transaction.
\end_layout

\begin_layout Itemize

\emph on
Serialization anomaly
\emph default
 - the result of successfully committing group of transactions is inconsistent
 with all possible orderings of running those transactions one at a time.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
There are 4 isolation levels:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Read uncommitted
\emph default
 - PostgreSQL doesn't implement this one.
 This allows 
\emph on
dirty reads
\emph default
.
\end_layout

\begin_layout Itemize

\emph on
Read committed
\emph default
 - disallows 
\emph on
dirty read 
\emph default
anomalies.
 This is the default isolation level in PostgreSQL.
 When a transaction uses this isolation level, a 
\emph on
select 
\emph default
query (without a 
\emph on
for update/share
\emph default
 clause) sees only data committed before the query began; it never sees
 either uncommitted data or changes committed during query execution by
 concurrent transactions.
 In effect, a 
\emph on
select 
\emph default
query sees a snapshot of the database as of the instant the query begins
 to run.
 However, 
\emph on
select 
\emph default
does see the effects of previous updates executed within its own transaction,
 even though they are not yet committed.
 Also note that two successive 
\emph on
select 
\emph default
commands can see different data, even though they are within a single transactio
n,
\end_layout

\begin_layout Itemize

\emph on
Repeatable read
\emph default
 - disallows 
\emph on
dirty read 
\emph default
and 
\emph on
nonrepeatable read.
 
\emph default
PostgreSQL also disallows 
\emph on
phantom read
\emph default
 here.
 This level only sees data committed before the transaction began; it never
 sees either uncommitted data or changes committed during transaction execution
 by concurrent transactions.
\end_layout

\begin_layout Itemize

\emph on
Serializable - 
\emph default
disallows all anomalies.
 It should be noted, that the authors of PostgreSQL did amazing work here,
 it took 20 years for the research community to come up with a satisfying
 mathematical model for implementing 
\emph on
serializable snapshot isolation (SSI) 
\emph default
in an efficient way, and then a single year for that major progress to be
 included in PostgreSQL.
 However, like the Repeatable Read level, applications using this level
 must be prepared to retry transactions due to serialization failures.
 In fact, this isolation level works exactly the same as Repeatable Read
 except that it monitors for conditions which could make execution of a
 concurrent set of serializable transactions behave in a manner inconsistent
 with all possible serial (one at a time) executions of those transactions.
\end_layout

\begin_layout Standard
We can change isolation level setting in PostgreSQL with: 
\emph on
start transaction isolation level repeatable read;
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
TIP: Sometimes, replacing an 
\emph on
update 
\emph default
with an 
\emph on
insert 
\emph default
is useful for concurrency behavior and locking.
\end_layout

\begin_deeper
\begin_layout Itemize
During 
\emph on
update, 
\emph default
a transaction has to wait until all concurrent transactions are done (a
 given row is locked).
\end_layout

\begin_layout Itemize
The 
\emph on
insert 
\emph default
has no concurrency because it targets a row that doesn't exist yet.
 We register each action into its own tuple and require no locking to do
 that, allowing our production setup of PostgreSQL to 
\series bold
sustain a much larger load
\series default
.
\end_layout

\end_deeper
\begin_layout Itemize
You can manually lock entire table if you need some very critical operation:
 
\emph on
lock table target_table in share row exclusive mode; 
\emph default
And this must be done on every transaction you want to.
 This can be useful if, for example, you insert a lot of values in a batch.
 An alternative is to use 
\emph on
on conflict do nothing 
\emph default
clause.
\end_layout

\begin_layout Itemize

\series bold
Types of locks in PostgreSQL:
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/explicit-locking.html}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Table-level Locks 
\emph default
- every query that runs on a given table takes a lock on the table.
 Table-level locks are used to block reads and/or writes to the table using
 
\emph on
DDL
\emph default
 commands.
 However, not all DDL commands need to block reads or writes, some only
 block each other.
\end_layout

\begin_layout Itemize

\emph on
Row-level Locks 
\emph default
- every row can be lock with 
\emph on
RowShareOnly
\emph default
 or 
\emph on
RowExclusive 
\emph default
locks.
 Many transactions can hold a share lock concurrently, but only one transaction
 can hold an exclusive lock.
 If concurrent transactions modify the same row, one of them will get blocked
 on a row lock.
 You can also take row-level locks without modifying anything using 
\emph on
select ...
 for update
\emph default
, or 
\emph on
select ...
 for share
\emph default
, which lets you temporarily prevent changes to a set of rows.
\end_layout

\begin_layout Itemize

\emph on
Page-level Locks
\end_layout

\begin_layout Itemize

\emph on
Deadlocks
\end_layout

\begin_layout Itemize

\emph on
Advisory Locks 
\emph default
- these are database locks, that are meant to be used by applications.
 They can be used for example from 
\emph on
PL/PgSQL
\emph default
 functions.
 Advisory locks can be split into 2 categories:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
exclusive advisory locks
\emph default
 - this will block any exclusive or shared advisory lock on the same lock
 key,
\end_layout

\begin_layout Itemize

\emph on
shared advisory locks
\emph default
 - this will block any exclusive advisory lock on the same lock key while
 still allowing other shared advisory locks to be acquired for the same
 lock key.
\end_layout

\begin_layout Standard
Based on their scope, there are two types of advisory locks that you can
 acquire in PostgreSQL:
\end_layout

\begin_layout Itemize

\emph on
Session-level advisory locks
\end_layout

\begin_layout Itemize

\emph on
Transaction-level advisory locks
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Beware of lock queues, use lock timeouts
\end_layout

\begin_deeper
\begin_layout Itemize
PostgreSQL uses lock queues - multiple processes can wait for the same lock.
 Processes are unlocked once their predecessor releases the lock.
\end_layout

\begin_layout Itemize
If you try to execute 
\emph on
DDL
\emph default
 command, it will wait for all running statements and it will block all
 other queries (even 
\emph on
select
\emph default
) in the meantime.
\end_layout

\begin_layout Itemize
If you must alter table which is used in long running select statements,
\end_layout

\begin_deeper
\begin_layout Itemize
never do this: 
\emph on
alter table items add column last_update timestamptz;
\end_layout

\begin_layout Itemize
do this instead: set lock_timeout to '2s' alter table items add column last_upda
te timestamptz;
\end_layout

\end_deeper
\end_deeper
\begin_layout Subsection
Caching
\end_layout

\begin_layout Itemize

\series bold
Any SQL query executed by PostgreSQL uses a snapshot of the whole database
 system.
 To create a cache from that snapshot, the simplest way is to use the create
 table as command:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create table some_table as select count(*) from another_table;
\end_layout

\end_deeper
\begin_layout Subsubsection
View
\end_layout

\begin_layout Itemize
Views allow integrating server-side computation in the definition of a relation.
 The computing still happens dynamically at query time and is made transparent
 to the client.
 When using a view, there’s no problem with 
\emph on
cache invalidation
\emph default
, because nothing gets cached away.
\end_layout

\begin_layout Itemize
Making liberal use of views is a key aspect of good SQL database design.
 Views allow you to encapsulate the details of the structure of your tables,
 which might change as your application evolves, behind consistent interfaces.
\end_layout

\begin_layout Itemize
Views can be used in almost any place a real table can be used.
 Building views upon other views is not uncommon.
\end_layout

\begin_layout Itemize
An example: 
\emph on
create view table some_view as select count(*) from some_table; 
\emph default
Given this view, an application code can query 
\emph on
some_view
\emph default
 and process the same relation; the view hides the 
\bar under
complexity
\bar default
 of how to obtain the result from the schema.
\end_layout

\begin_layout Itemize

\series bold
Difference between stored functions and views
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://stackoverflow.com/questions/1603853/sql-server-performance-what-is-fa
ster-a-stored-procedure-or-a-view}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
View
\emph default
 is a virtual table, that does not physically exist.
\end_layout

\begin_layout Itemize

\emph on
Stored procedure
\emph default
 is a group of statements compiled into a single execution plan.
 A stored function is a named PL/SQL block which is similar to a procedure.
 The major difference between a procedure and a function is, a function
 must always return a value, but a procedure may not.
 SPs are more versatile and allow a broader range of actions than the views.
\end_layout

\end_deeper
\begin_layout Subsubsection
Materialized View
\begin_inset CommandInset label
LatexCommand label
name "subsec:Materialized-View"

\end_inset


\end_layout

\begin_layout Itemize
It is easy enough to cache a snapshot of the database into a permanent relation
 for later querying thanks to PostgreSQL implementation of 
\emph on
materialized views
\emph default
.
\end_layout

\begin_layout Itemize
When some information is needed way more often than it changes, having a
 
\emph on
cache
\emph default
 is a good idea.
 An easy way to build one in PostgreSQL is to use a 
\emph on
materialized view: create schema if not exists v; create schema if not exists
 cache; create view v.something as ...
 some query ...; create materialized view cache.some_materialized_view as select
 * from v.some_table; create index on cache.some_table(some_column);
\end_layout

\begin_layout Itemize
We can firstly create a classic 
\emph on
view
\emph default
 that computes something, and then build a 
\emph on
materialized view
\emph default
 on top of it.
\end_layout

\begin_layout Itemize
You must also consider cache invalidation.
 It is easy in PostgreSQL, you just have to refresh materialized view query
 - so, to invalidate the cache and compute the data again: 
\emph on
refresh materialized view cache.season_points; 
\emph default
This command makes it possible to implement a
\emph on
 cache invalidation policy
\emph default
.
 In some cases, a business only analyses data up to the day before, in which
 case you can 
\emph on
refresh
\emph default
 your materialized views every night: that’s your cache invalidation policy.
\end_layout

\begin_layout Itemize
The 
\emph on
cache.some_table
\emph default
 relation is locked out from even 
\emph on
select 
\emph default
activity while its content is being computed again.
 For very simple materialized view definitions it is possible to refresh
 concurrently and avoid locking out concurrent readers.
\end_layout

\begin_layout Itemize
Once this materialized view is created, we can use it and write queries
 as a normal table.
\end_layout

\begin_layout Subsection
Triggers
\end_layout

\begin_layout Itemize
Event-based processing facility that allows 
\series bold
registering a procedure to be
\series default
 
\series bold
executed
\series default
 
\series bold
at
\series default
 a specified timing when 
\series bold
an
\series default
 
\series bold
event
\series default
 is produced.
 The timing can be 
\emph on
before, after
\emph default
, or
\emph on
 instead of
\emph default
, and the event can be 
\emph on
insert, update, delete, 
\emph default
or
\emph on
 truncate.
 .
\end_layout

\begin_layout Itemize
In PostgreSQL, usually triggers are written in 
\begin_inset CommandInset href
LatexCommand href
name "PL/pgSQL language"
target "https://www.postgresql.org/docs/current/static/plpgsql.html"
literal "false"

\end_inset

, but it is possible to write procedures and triggers in other programming
 languages, such as 
\begin_inset CommandInset href
LatexCommand href
name "PL/Python"
target "https://www.postgresql.org/docs/current/plpython.html"
literal "false"

\end_inset

 or 
\begin_inset CommandInset href
LatexCommand href
name "C"
target "https://www.postgresql.org/docs/current/xfunc-c.html"
literal "false"

\end_inset

.
 Unfortunately it is not possible to write triggers in plain SQL language,
 so we have to write stored procedures to benefit from the PostgreSQL trigger
 capabilities.
\end_layout

\begin_layout Itemize
PostgreSQL triggers call a registered procedure each time one of the supported
 events is committed.
 The execution of the procedure is always taken as a part of the transaction,
 so
\series bold
 if your procedure fails at runtime then the whole transaction is aborted
\series default
.
\end_layout

\begin_layout Itemize
An example of such event driven processing with a trigger - 
\emph on
update 
\emph default
something each time there is a related 
\emph on
insert
\emph default
 in the 
\emph on
some_schema.some_table
\emph default
 table.
 Each time, if there is an insert on 
\emph on
some_schema.some_table
\emph default
, this trigger will transform the 
\emph on
insert 
\emph default
into an 
\emph on
update
\emph default
 against a single row (or insert, if a record does not exist - so it is
 basically an 
\emph on
upsert
\emph default
).
 Or even better, 
\emph on
insert ..
 on conflict do update ..
 
\emph default
approach
\emph on
.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
begin;
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
create table cache.some_table (...);
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
create or replace function cache.tg_some_func()
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

returns trigger
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

language plpgsql
\end_layout

\begin_layout Standard

\emph on
as $$
\end_layout

\begin_layout Standard

\emph on
declare
\end_layout

\begin_layout Standard

\emph on
begin
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

...
 some_implementation (for example update cache.some_table)...
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if not found
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

then
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

...
 some_other_implementation (for example insert into cache.some_table...on conflict..)
 ...
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

end if;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return null;
\end_layout

\begin_layout Standard

\emph on
end;
\end_layout

\begin_layout Standard

\emph on
$$;
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
create trigger some_func
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

after insert
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

on some_schema.some_table
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

for each row
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

execute procedure cache.tg_some_func();
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
insert into some_schema.some_table(params) values (...);
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Event triggers
\series default
 - another kind of triggers.
 They allow one to implement triggers on any event that to source code integrate
s.
 They are mainly provided for DDL commands.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/event-trigger-definition.html}}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Listen and Notify
\end_layout

\begin_layout Itemize
PostgreSQL protocol includes a streaming protocol with 
\emph on
copy
\emph default
 and also implements asynchronous messages and notifications.
 This means, that as soon as a connection is established with PostgreSQL,
 the server can send messages to the client even when the client is idle.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
listen channel;
\end_layout

\begin_layout Standard

\emph on
notify channel, 'hello';
\end_layout

\begin_layout Standard
This message could be sent from another connection for example.
 The payload ('hello') from the message can be any text, up to 8kB in length.
 This allows for rich messages to flow, such as JSON encoded values.
\end_layout

\end_deeper
\begin_layout Itemize
It is possible for our trigger to 
\emph on
notfy 
\emph default
an external client.
 This client must be a daemon program, which uses 
\emph on
listen
\emph default
 to register our messages.
 Each time a notification is sent, the daemon program processes it.
 As we have a single daemon program listening to notifications and updating
 the cache, we now bypassed the concurrency issues.
\end_layout

\begin_layout Itemize
PostgreSQL 
\emph on
listen
\emph default
 and 
\emph on
notify
\emph default
 support is perfect for maintaining a cache.
 Because notifications are only delivered to client connections that are
 listening at the moment of the notify call, our cache maintenance service
 must implement the following behavior, in this exact order:
\end_layout

\begin_deeper
\begin_layout Enumerate
Connect to the PostgreSQL database we expect notifications from, and issue
 the 
\emph on
listen 
\emph default
command
\emph on
.
\end_layout

\begin_layout Enumerate
Fetch the current values from their 
\emph on
single source of truth
\emph default
 and reset the cache with those computed values.
\end_layout

\begin_layout Enumerate
Process notifications as they come and update the in-memory cache, and once
 in a while synchronize the in-memory cache to its materialized location,
 as per the 
\emph on
cache invalidation policy
\emph default
.
\end_layout

\begin_layout Standard
The cache service can be implemented within the cache maintenance service.
 As an example, a cache server application might both process notifications
 and serve the current cache from memory over an HTTP API.
 The cache service might also be one of the popular cache solutions such
 as 
\begin_inset CommandInset href
LatexCommand href
name "Memcached"
target "https://memcached.org/"
literal "false"

\end_inset

 or 
\begin_inset CommandInset href
LatexCommand href
name "Redis"
target "https://redis.io/"
literal "false"

\end_inset

.
\end_layout

\end_deeper
\begin_layout Itemize
Support for listen and notify PostgreSQL functionality depends on the driver
 you’re using.
 For instance, for Python, the 
\begin_inset CommandInset href
LatexCommand href
name "Psycopg"
target "http://initd.org/psycopg/"
literal "false"

\end_inset

 driver is the most popular and supports a lot of this stuff.
\end_layout

\begin_layout Section
General
\end_layout

\begin_layout Itemize
The rule of thumb is to never forget what your ORM is meant for: translate
 SQL records into Python objects.
 If you think it can handle anything more, like avoiding writing SQL, managing
 indices etc.
 .
 .
 you are wrong.
\end_layout

\begin_layout Itemize
See the version of PostgreSQL you are using:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> show server_version;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
SQL is a code - if must follow SQL style guidelines.
 No caps-locks, we have syntax highlighters in this century! Right align
 top-level SQL clauses and have them on new lines:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select title, name
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from album left join track using(albumid)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

where albumid = 1
\end_layout

\begin_layout Standard
order by 2;
\end_layout

\end_deeper
\begin_layout Itemize
An alternative extended style using subqueries and having join on separate
 line would be :
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select title, name, milliseconds
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from (
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select albumid, title
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

album
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join artist using(artistid)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

where artist.name = 'AC/DC'
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

as artist_albums
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

left join track using(albumid)
\end_layout

\begin_layout Standard
order by trackid;
\end_layout

\end_deeper
\begin_layout Itemize
PSQL execution:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://serverfault.com/questions/110154/whats-the-default-superuser-username
-password-for-postgres-after-a-new-install}}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$ sudo -i -u postgres
\end_layout

\begin_layout Description
# alebo 
\end_layout

\begin_layout Description
$ su - postgres
\end_layout

\begin_layout Description
$ sudo -u postgres psql postgres
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Creating extension - only 1 extension with the same name can exist in a
 given database.
\end_layout

\begin_deeper
\begin_layout Standard
BEGIN;
\end_layout

\begin_layout Standard

\series bold
CREATE EXTENSION
\series default
 pgcrypto;
\end_layout

\begin_layout Standard
END;
\end_layout

\end_deeper
\begin_layout Itemize
Useful tools and commands: 
\emph on
pgloader
\emph default
, 
\emph on
anosql
\emph default
,
\emph on
 psql, explain plan
\emph default
.
\end_layout

\begin_layout Itemize
Writing a query happens interactively using the SQL REPL tool - 
\emph on
psql
\emph default
 (more specifically, 
\emph on
psql
\emph default
 implements 
\emph on
REPL - read-eval-print loop
\emph default
).
 It can be used for scripting and interactive usage it is very powerful
 tool.
\end_layout

\begin_layout Itemize

\emph on
Null
\emph default
 - a very special value that introduces 
\series bold
three-valued logic
\series default
.
 A result of some logical statement can be 
\emph on
true
\emph default
,
\emph on
 false
\emph default
, or 
\emph on
null
\emph default
.
 We can think about 
\emph on
null
\emph default
 as 
\emph on
I don't know what this is
\emph default
, rather than 
\emph on
no value here
\emph default
.
 Even 
\emph on
null = null 
\emph default
results in 
\emph on
null.
\end_layout

\begin_deeper
\begin_layout Itemize
For avoiding this three-valued logic, we can use 
\emph on
distinct from
\emph default
 and 
\emph on
is not distinct from
\emph default
, see an example below.
\end_layout

\begin_layout Itemize
Most programming languages come with a representation of the unknown or
 not yet initialized state, be it 
\emph on
None
\emph default
 in Python for instance.
 Depending on your tools of choice the 
\emph on
null
\emph default
 SQL value maps quite directly to those concepts.
 The main thing is then to 
\series bold
remember 
\series default
that
\series bold
 you might get 
\emph on
null
\emph default
 in your results set
\series default
, and 
\series bold
you should write your code accordingly
\series default
.
 The next main thing to keep in mind is the three-valued logic semantics
 when you write SQL, and 
\series bold
remember to use 
\emph on
where
\emph default
 
\emph on
foo is null
\emph default
 if that’s what you mean, rather than the erroneous 
\emph on
where foo = null
\series default
\emph default
, because 
\emph on
null = null 
\emph default
is 
\emph on
null
\emph default
 and then it won’t be selected in your resultset.
\end_layout

\begin_layout Itemize

\emph on
NULLs
\emph default
 can exist inside some things, but not others — If you concatenate: firstname
 || mi || lastname, and “mi” happens to be null, the entire result will
 be null.
 So strings cannot contain a 
\emph on
NULL
\emph default
, but as we see above, a record can.
\end_layout

\begin_layout Itemize

\series bold
You should not attempt to apply your intellect to 
\emph on
NULL
\series default
\emph default
, it will lead you in the wrong direction.
 If you need to understand it, understand it, but always treat it with skepticis
m.
 Test the queries, read the standard, do what you need to do, but do not
 attempt to extrapolate.
\end_layout

\begin_layout Itemize
Aggregates ignore 
\emph on
NULLs
\emph default
 — According to the standard, aggregates are supposed to ignore 
\emph on
NULLs
\emph default
, because the information is missing.
\end_layout

\end_deeper
\begin_layout Section
PSQL
\end_layout

\begin_layout Itemize
Customization with 
\emph on
~/.psqlrc 
\emph default
file; if you want to omit this file, then run 
\emph on
psql –no-psqlrc
\emph default
 and if you want to output HTML format, type 
\emph on
-P format=html
\emph default
 and if you want to run a specific SQL file, type 
\emph on
-f file.sql
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
install pspg and customize the config.
\end_layout

\begin_layout Itemize

\emph on

\backslash
setenv PAGER '/usr/bin/pspg -bX --no-mouse'
\end_layout

\begin_layout Standard
in .bashrc file:
\end_layout

\begin_layout Itemize
export PGDATABASE=postgres
\end_layout

\begin_layout Itemize
export PGHOST=localhost
\end_layout

\begin_layout Itemize
export PGUSER=lsulak
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Other clients -
\series default
 
\series bold

\begin_inset CommandInset href
LatexCommand href
name "pgAdmin"
target "https://www.pgadmin.org/"
literal "false"

\end_inset

, 
\begin_inset CommandInset href
LatexCommand href
name "pgcli"
target "https://www.pgcli.com/"
literal "false"

\end_inset

 
\series default
(python, code completion, highlighting)
\end_layout

\begin_layout Itemize
To see more verbose output or some commands, type 
\emph on

\backslash
set ECHO_HIDDEN true
\emph default
.
 See what's happen with command 
\emph on

\backslash
l+ 
\emph default
(or other so called 
\emph on
catalog queries
\emph default
).
\end_layout

\begin_layout Itemize
For launching your editor inside 
\emph on
psql
\emph default
 on the last edited query (or an empty one) in a temporary file, and for
 executing the query once you end the editing session, type 
\emph on

\backslash
e
\emph default
 (editor will be chosen according to 
\emph on
psqlrc 
\emph default
file).
\end_layout

\begin_layout Itemize
It is also possible to run 
\emph on
psql 
\emph default
on some specific (even remote) database: 
\emph on
psql -d dbname -h hostname -p port -U username
\end_layout

\begin_layout Itemize
Create a new database:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> create database dbnameX with owner=postgres template=template0 encoding='
UTF8' lc_collate='en_US.UTF-8' lc_ctype='en_US.UTF-8';
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Connect to it:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> 
\backslash
c dbnameX
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Load input file with SQL queries:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> 
\backslash
i input
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
See the database:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> 
\backslash
d
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
See a specific table:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> 
\backslash
d table
\end_layout

\begin_layout Description
$psql> 
\backslash
d+ table # pre vypis struktury tabulky
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Help to all 'backslash' commands:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
?
\end_layout

\end_deeper
\begin_layout Itemize
See the description of query result (without its execution):
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
gdesc
\end_layout

\end_deeper
\begin_layout Itemize
Lists access rights (privileges) to tables:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
dp
\end_layout

\end_deeper
\begin_layout Itemize
Lists installed extensions:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
dx
\end_layout

\end_deeper
\begin_layout Itemize
Changes output to 'pure' data (no header, ...):
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
t
\end_layout

\end_deeper
\begin_layout Itemize
See users: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> 
\backslash
l
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
SQL commands execution from file via terminal: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$ psql -U <user> -h <hostname> <db_user> < commands.sql
\end_layout

\begin_layout Plain Layout
# or
\end_layout

\begin_layout Description
$ psql -E -X -1 -U <user> -h <hostname> <db_user> [-f SQL_FILE / -c SQL_COMMAND]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Copy query results to output file:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> COPY (query) TO 'cesta' (DELIMITER ';');
\end_layout

\begin_layout Description
# or
\end_layout

\begin_layout Description
$psql> 
\backslash
copy (query) TO 'cesta' delimiter ';';
\end_layout

\begin_layout Description
# or
\end_layout

\begin_layout Description
$psql> 
\backslash
o 'cesta'
\end_layout

\begin_layout Description
# or copy CSV
\end_layout

\begin_layout Description
$psql> 
\backslash
copy factbook from 'factbook.csv' with delimiter E'
\backslash
t' null ''
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Logout of all logged in users:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select pg_terminate_backend(pid) from pg_stat_activity where pid <> pg_backend_p
id() ;
\end_layout

\end_deeper
\begin_layout Itemize
See all logged in users:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select * from pg_stat_activity;
\end_layout

\end_deeper
\begin_layout Itemize
See a list of databases:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
l
\end_layout

\end_deeper
\begin_layout Itemize
See a list of tables:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
dt+
\end_layout

\end_deeper
\begin_layout Itemize
See a list of views:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
dv
\end_layout

\end_deeper
\begin_layout Itemize
See a list of functions:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
df *filter*
\end_layout

\end_deeper
\begin_layout Itemize
See a source code of function:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
sf function
\end_layout

\end_deeper
\begin_layout Itemize
Switching between row-like and column-like view:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
x
\end_layout

\end_deeper
\begin_layout Itemize
Measuring time of query:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on

\backslash
timing on
\end_layout

\end_deeper
\begin_layout Itemize
See the last activity:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> select * from pg_stat_activity;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Show the path to the PostgreSQL's configuration:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> SHOW hba_file;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Transfer database from 
\bar under
root
\bar default
 to 
\bar under
home
\bar default
 (due to disk space) is sometimes more than needed
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://ask.fedoraproject.org/en/question/72644/moving-postgresql-94-data-dire
ctory-in-fedora-22/}}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://wiki.postgresql.org/wiki/Move_PGDATA_Fedora_17}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Use dblink - if for example, I want to get data from some remote database
 and I am working from localhost: 
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> 
\backslash
copy (select maldoms.* from dblink('dbname=db_name port=5432 host=10.0.X.X user=user
X password=XXXX', 'SELECT QUERY') as maldoms (value text)) TO 'cesta' delimiter
 ';';
\end_layout

\begin_layout Description
$psql> select maldoms.* from dblink('dbname=db_name port=5432 host=10.0.X.X
 user=userX password=XXXX', 'SELECT QUERY') as maldoms (id int, source character
 varying(255));
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Dump database on remote host to file:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
$ pg_dump -U username -h hostname databasename > dump.sql
\end_layout

\end_deeper
\begin_layout Itemize
Command 
\emph on
pg_dump
\emph default
 does not store a list of users of database.
 For exporting also a list of users (roles), it is need to use command 
\emph on
pg_dumpall -r.
\end_layout

\begin_layout Itemize
Import dump into existing database
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
$ psql -d newdb -f dump.sql
\end_layout

\end_deeper
\begin_layout Itemize
Select with limit and its equivalent variants:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Plain Layout
select * from races limit 1;
\end_layout

\begin_layout Plain Layout
select * from races fetch first 1 rows only;
\end_layout

\begin_layout Plain Layout
table races limit 1;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Never use 
\emph on
offset
\emph default
 clause
\series default
, it is very bad for your query performance!
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://use-the-index-luke.com/sql/partial-results/fetch-next-page}}
\end_layout

\end_inset

 
\series bold
The 
\emph on
offset
\emph default
 clause is going to cause your SQL query plan to read all the result anyway
 and then discard most of it until reaching the offset count.

\series default
 When paging through lots of results, it’s less and less efficient with
 each additional page you fetch that way.
 The proper way to implement pagination is to use index lookups, and if
 you have multiple columns in your ordering clause, you can do that with
 the 
\emph on
row()
\emph default
 construct.
\end_layout

\begin_deeper
\begin_layout Itemize
To show an example of the method, we are going to 
\bar under
paginate
\bar default
 through the 
\emph on
laptimes
\emph default
 table, which contains every lap time for every driver in any race.
 For the raceid 972 that we were having a look at earlier, that’s a result
 with 828 lines.
 Of course, we’re going to need to paginate through it.
 Here’s how to do it properly, given pages of three rows at a time, to save
 space in this book for more interesting text.
 The first query is as expected:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select lap, drivers.code, position,
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

milliseconds * interval '1ms' as laptime
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from laptimes
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join drivers using(driverid)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

where raceid = 972
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

order by lap, position
\end_layout

\begin_layout Standard
fetch first 3 rows only;
\end_layout

\end_deeper
\begin_layout Itemize
The result set is important because your application needs to make an effort
 here and remember that it did show you the results up until lap = 1 and
 position = 3.
 We are going to use that so that our next query shows the next page of
 results:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select lap, drivers.code, position,
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

milliseconds * interval '1ms' as laptime
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from laptimes
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join drivers using(driverid)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

where raceid = 972
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and row(lap, position) > (1, 3)
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

order by lap, position
\end_layout

\begin_layout Standard
fetch first 3 rows only;
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
The query optimizer takes 
\emph on
limit
\emph default
 into account when generating query plans, so you are very likely to get
 different plans (yielding different row orders) depending on what you give
 for 
\emph on
limit
\emph default
 and 
\emph on
offset
\emph default
.
 Thus, using different 
\emph on
limit
\emph default
/
\emph on
offset
\emph default
 values to select different subsets of a query result will give inconsistent
 results unless you enforce a predictable result ordering with 
\emph on
order by
\emph default
.
\end_layout

\begin_layout Itemize
Transaction:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
BEGIN; 
\end_layout

\begin_layout Plain Layout
UPDATE QUERY; 
\end_layout

\begin_layout Plain Layout
END;
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
It is possible to use 
\emph on
savepoint <savepoint_name> 
\emph default
with 
\emph on
rollback to <savepoint_name> 
\emph default
to control the statements in a transaction in a more granular fashion.
 Save-points allow you to selectively discard parts of the transaction,
 while committing the rest.
 After rolling back to a savepoint, it continues to be defined, so you can
 roll back to it several times.
 Conversely, if you are sure you won't need to roll back to a particular
 savepoint again, it can be released, so the system can free some resources.
 Keep in mind that either releasing or rolling back to a savepoint will
 automatically release all save-points that were defined after it.
\end_layout

\begin_layout Itemize
Useful command it 
\emph on
pg_stat_activity
\emph default
.
\end_layout

\begin_layout Itemize
Watching queries in real-time:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
$psql> select pid, state, datname, usename, query_start, substring(query
 from 0 for 150) as query from pg_stat_activity 
\backslash
watch [check_period_in_secs]
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Section
PL/pgSQL
\end_layout

\begin_layout Itemize
Procedural programming language based on PL/SQL, coming from ADA.
 It is ideal for SQL queries, that can be executed directly on server.
\end_layout

\begin_layout Itemize
Minimalism - SQL + variables + some basic constructions.
 Support of out parameters and polymorphic functions, triggers, and functions
 (there are no procedures).
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create of replace function fib(prvku int)
\end_layout

\begin_layout Standard

\emph on
returns setof int as $$
\end_layout

\begin_layout Standard

\emph on
declare
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

a int = 0;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

b int = 0;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

c int;
\end_layout

\begin_layout Standard

\emph on
begin for i in 1..prvku loop
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

c := case a + b when 0 then 1
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

else a + b end;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

a := b;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

b := c;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return next c;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

end loop;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return;
\end_layout

\begin_layout Standard

\emph on
end
\end_layout

\begin_layout Standard

\emph on
$$ language plpgsql immutable strict;
\end_layout

\end_deeper
\begin_layout Itemize
An example:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create or replace function new_employee(name text, full_time_contract boolean)
\end_layout

\begin_layout Standard

\emph on
returns void as $$
\end_layout

\begin_layout Standard

\emph on
begin
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if full_time_contract then insert into employees values (new_employee.name);
\end_layout

\begin_layout Standard

\emph on
else
\end_layout

\begin_layout Standard

\emph on
insert into external_employees values(new_employee.name);
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

end if;
\end_layout

\begin_layout Standard

\emph on
end;
\end_layout

\begin_layout Standard

\emph on
$$ language plpgsql;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
select new_employee('Sulak, true');
\end_layout

\begin_layout Standard

\emph on
select new_employee(name => 'Sulak', true);
\end_layout

\end_deeper
\begin_layout Itemize
It is also possible to use 
\series bold
\emph on
variadic functions
\series default
\emph default
.
 These are functions with variable number of parameters.
 The last parameter of this function is so called variadic parameter of
 type array.
 For example, implementation of minimum number from a list of numbers:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create or replace function minimum(
\series bold
variadic numeric[]
\series default
)
\end_layout

\begin_layout Standard

\emph on
returns numeric as $$
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select min(v) from unnest($1) g(v);
\end_layout

\begin_layout Standard

\emph on
$$ language sql;
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
select minimum(10,1,2);
\end_layout

\begin_layout Standard

\emph on
select minimum(variadic array[10,1,2])
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
\emph on
Polymorphic functions 
\series default
\emph default
are generic functions that can have parameter of generic data type - 
\emph on
anyelement, anyarray, anynonarray, anyrange, 
\emph default
and
\emph on
 anyenum
\emph default
.
 Polymorphic function from the previous example could look like:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create or replace function minimum(
\series bold
variadic anyarray
\series default
)
\end_layout

\begin_layout Standard

\emph on
returns anyelement as $$
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select min(v) from unnest($1) g(v);
\end_layout

\begin_layout Standard

\emph on
$$ language sql;
\end_layout

\end_deeper
\begin_layout Itemize
Code of any PostgreSQL function runs with access rights of a user, that
 called/activated a given function.
 The same situation is with triggers.
 This behavior is similar to user rights in Unix.
 But careful, in almost all other database systems, the situation is different
 - code inside of a function is executed with rights of 
\series bold
owner 
\series default
of a given function.
 In PostgreSQL, this behavior can be changed, with 
\emph on
security definer
\emph default
 attribute of a function.
 This technique can be used when we want to access data, to which an access
 should not be granted normally.
 The advantage of this approach is that when an attacker is able to compromise
 an access of ordinary user, he does not gain access to table 
\emph on
users.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create or replace function verify_login(username text, password text)
\end_layout

\begin_layout Standard

\emph on
returns boolean as $$
\end_layout

\begin_layout Standard

\emph on
begin
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

if exists(select * from users u where u.passwd = md5(verify_login.password)
 and u.name = verify_login.usrname)
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

then
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return true;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

else
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

raise warning 'unsuccessful login: %', usrname;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

perform pg_sleep(random() * 3);
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return false;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

end;
\end_layout

\begin_layout Standard

\emph on
end;
\end_layout

\begin_layout Standard

\emph on
$$ 
\series bold
security definer
\end_layout

\begin_layout Standard

\emph on
language plpgsql;
\end_layout

\end_deeper
\begin_layout Section
SQLAlchemy
\end_layout

\begin_layout Itemize
Initiation
\end_layout

\begin_deeper
\begin_layout Itemize
create_engine() if also echo=True as another parameter to create_engine,
 then we'll see raw sql queries coming from ORM
\end_layout

\begin_layout Itemize
metadata (classes MetaData, Table, Column, ForeignKeyConstraint, ...) DB descriptio
n, some methods: create_all, drop_all, reflect, tables, ...
 
\end_layout

\begin_layout Itemize
ORM - object relational mapper - representing a set of classes, coming from
 a DB entity.
 In general, every mapping class corresponds with table in SQL DB.
\end_layout

\begin_deeper
\begin_layout Itemize
define class what will be mapped (in constructor columns from DB table)
 
\end_layout

\begin_layout Itemize
orm.mapper() for the mapping itself.
 You can use various parameters, for example for defining properties (1:M
 relation etc.) 
\end_layout

\end_deeper
\begin_layout Itemize
session - mechanism for executing DB operations - container for a group
 of similar operations, doing a transaction.
 Data are inserted to a DB after a commit.
 Creating session - orm.sessionmaker().
\end_layout

\end_deeper
\begin_layout Itemize
Queries
\end_layout

\begin_deeper
\begin_layout Itemize
We can work with ti as a generator; possible operators:
\end_layout

\begin_deeper
\begin_layout Itemize
all() isn't good for big amount of data, it returns a bit list
\end_layout

\begin_layout Itemize
count() 
\end_layout

\begin_layout Itemize
delete() removes tables, be careful about foreign key relationships, you
 have to remove those first
\end_layout

\begin_layout Itemize
filter() returns Query instance, which contains only certain rows
\end_layout

\begin_layout Itemize
filter_by() returns Query instance, which contains only rows of a table,
 with certain values of columns
\end_layout

\begin_layout Itemize
first() 
\end_layout

\begin_layout Itemize
get() returns single result row, for example according to a primary key
\end_layout

\begin_layout Itemize
one() returns 1 record.
 If there is more, an exception is raised
\end_layout

\begin_layout Itemize
join() 
\end_layout

\begin_layout Itemize
order_by()
\end_layout

\end_deeper
\begin_layout Itemize
it's possible to return a normal tuple (results via indexes- t[1]), or 
\begin_inset Quotes eld
\end_inset

result tuple
\begin_inset Quotes erd
\end_inset

 (references - t.name)
\end_layout

\end_deeper
\begin_layout Itemize
Reflector - for showing existing DB structure.
\end_layout

\begin_layout Section
Queries and Clauses
\end_layout

\begin_layout Itemize
See Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:SQL"
plural "false"
caps "false"
noprefix "false"

\end_inset

 for the list of areas SQL has, including PostgreSQL.
\end_layout

\begin_layout Itemize

\series bold
SQL injection 
\series default
- when you 
\series bold
separate query parameters from the main SQL query text
\series default
, 
\series bold
you don't ever have to worry about this problem
\series default
.
 The reason is that PostgreSQL implements a protocol level facility and
 if you send those parts as separate entities over the protocol, means that
 SQL injection is no longer possible.
 Be careful and read documentation of your current driver for understanding
 how to send SQL query parameters separately from main SQL query text.
 In particular, 
\series bold
never build a query string by concatenating your query arguments directly
 into your query strings
\series default
, i.e.
 in the application client code.
 Never use any library, ORM or another tooling that would do that.
 When building SQL query strings that way, you open your application code
 to serious security risk for no reason.
\end_layout

\begin_deeper
\begin_layout Itemize
You can use 
\emph on
prepare 
\emph default
and 
\emph on
execute
\emph default
 commands:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
prepare something as
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select date, shares, trades, dollars
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from factbook
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

where date >= $1::date
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and date < $1::date + interval '1 month'
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

order by date;
\end_layout

\end_deeper
\begin_layout Itemize
And then call it like 
\emph on
execute something('2010-02-021');
\end_layout

\begin_layout Itemize
Now, while it's possible to use the 
\emph on
prepare
\emph default
 and 
\emph on
execute
\emph default
 SQL commands directly in your application code, it is also possible to
 
\bar under
use it directly at the PostgreSQL protocol level
\bar default
.
 This facility is named 
\series bold
Extended Query 
\series default
and is well documented.
\end_layout

\begin_layout Itemize
In the extended protocol, the front-end first sends a 
\series bold
PARSE
\series default
 message, which contains a textual query string, optionally some information
 about data types of parameter placeholders, and the name of a destination
 prepared-statement object.
 And then, there is 
\series bold
BIND
\series default
 message.
 Once a prepared statement exists, it can be readied for execution using
 a Bind message.
 The supplied parameter set must match those needed by the prepared statement.
 Finally, to receive the result set the client needs to send a third message,
 the 
\series bold
EXECUTE
\series default
 message.
\end_layout

\begin_layout Itemize
So, the query string is sent in the BIND message.
 The query parameters are sent in the EXECUTE message.
 When doing things that way, it is impossible to have SQL injections.
\end_layout

\begin_layout Itemize
Remember: SQL injection happens when the SQL parser is fooled into believing
 that a parameter string is in fact a SQL query, and then the SQL engine
 goes on and executes that SQL statement.
 When the SQL query string lives in your application code, and the user-supplied
 parameters are sent separately on the network, there’s no way that the
 SQL parsing engine might get confused.
\end_layout

\end_deeper
\begin_layout Itemize
So we have: projection (
\emph on
select
\emph default
), data sources (
\emph on
from
\emph default
), 
\emph on
join
\emph default
 (outer or inner ones), restrictions (
\emph on
where
\emph default
), ordering (
\emph on
order by
\emph default
), top-N sorts (
\emph on
limit
\emph default
), aggregates (
\emph on
group by, having
\emph default
), result sets operations (
\emph on
union, intersect, except), 
\emph default
relations (
\emph on
create table, create type, or create view), insert, update, 
\emph default
and 
\emph on
delete.
\end_layout

\begin_layout Itemize

\emph on
Select 
\emph default
clause: there is 
\emph on
skip locked
\emph default
 option: 
\emph on
select ...
 for [key] update|share
\emph default
.
 You can use 
\emph on
nowait
\emph default
 or 
\emph on
skip locked 
\emph default
here, and it changes a behavior when the tuple is locked by another transaction.
 The main utility of 
\emph on
skip locked
\emph default
 is for building simple, reliable and efficient concurrent work queries.
\end_layout

\begin_deeper
\begin_layout Itemize
Basic syntax is as follows:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select avg(a.column1), b.column4
\end_layout

\begin_layout Standard

\emph on
from 
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

table1 a
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join table2 b
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

on a.column1 = b.column2
\end_layout

\begin_layout Standard

\emph on
where b.column3 = 'something'
\end_layout

\begin_layout Standard

\emph on
group by b.column4
\end_layout

\begin_layout Standard

\emph on
having avg(a.column1) > 100
\end_layout

\begin_layout Standard

\emph on
order by 1 limit 10;
\end_layout

\end_deeper
\begin_layout Itemize
An example, given a trivial queue:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create table queue (
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

itemid integer primary key,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

is_done boolean not null default 'f'
\end_layout

\begin_layout Standard

\emph on
);
\end_layout

\begin_layout Standard

\emph on
insert into queue (itemid)
\end_layout

\begin_layout Standard

\emph on
select x from generate_series(1,20) x;
\end_layout

\end_deeper
\begin_layout Itemize
An application can grab a single queue item safely while holding an open
 transaction:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
delete from queue
\end_layout

\begin_layout Standard

\emph on
where itemid = (
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select itemid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from queue
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

order by itemid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

for update skip locked
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

limit 1
\end_layout

\begin_layout Standard

\emph on
)
\end_layout

\begin_layout Standard

\emph on
returning *;
\end_layout

\end_deeper
\begin_layout Itemize
Here, the 
\emph on
queue 
\emph default
table is scanned in 
\emph on
itemid 
\emph default
order, and this mechanism tries to acquire a lock on each row.
 If it faults to acquire the lock, it ignores the row as if it wasn't in
 the table at all, and carries on.
 It stops scanning once it's locked one item.
 It returns the 
\emph on
itemid
\emph default
 of the locked item.
 It looks up the found 
\emph on
itemid
\emph default
 in the index to get its physical location.
 It marks the tuple as deleted, but this doesn't take effect until commit
 of course.
\end_layout

\begin_layout Itemize

\emph on
Case 
\emph default
statement is used for data transformation.
 There exist two approaches how to write it.
 The first one searches for a constant, the second one for expression:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select case column when 0 then 'no'
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

when 1 then 'yes' end
\end_layout

\begin_layout Standard

\emph on
from table;
\end_layout

\begin_layout Standard

\emph on
select case when column = 0 then 'no'
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

when column = 1 then 'yes' end
\end_layout

\begin_layout Standard

\emph on
from table;
\end_layout

\begin_layout Itemize
In case, that nothing will be matched (no constant is found or no expression
 is true), then the resulting value is either defined with 
\emph on
else
\emph default
, or if it is missing, then the result is 
\emph on
null.
\end_layout

\end_deeper
\begin_layout Itemize
The open transaction holds a lock on the row now.
 Other transactions will skip it so long as this transaction keeps on running.
 If this transaction aborts, the row becomes unlocked and the deletion is
 undone by the abort so another transaction can grab the row.
 If this transaction commits, the deletion is committed.
\end_layout

\begin_layout Itemize
There are also some downsides to using 
\emph on
skip locked
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
Each transaction scans the table and skips over locked rows, so with 
\series bold
high numbers of active workers
\series default
 it can land up doing a bit of work to acquire a new item.
 It’s not just popping items off a stack.
 The query will probably have to walk an index with an index scan, fetching
 each candidate item from the heap and checking the lock status.
 With any reasonable queue this will all be in memory but it’s still a fair
 bit of churn.
\end_layout

\begin_layout Itemize

\series bold
A queue implemented in the RDBMS will never match the performance of a fast
 dedicated queuing system
\series default
, even one that makes the same atomicity and durability guarantees as PostgreSQL.
 Using 
\emph on
skip locked
\emph default
 is better than existing in-database approaches, but
\series bold
 you'll still go faster using a dedicated and highly optimized external
 queuing engine.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Subqueries
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Subquery in where, 
\emph default
for filtering purposes for example.
\end_layout

\begin_deeper
\begin_layout Standard
select name from cities c where c.region_id = (select id from regions where
 code = 'NR') - - select all cities from Nitra's region
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Correlated subquery
\emph default
.
 This can reference to result, that produces the outer query:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select name, surname from employees e where exists(select id from children
 ch where ch.employee_id = e.id) - - find employees that have children
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Subquery in from clause
\emph default
.
 This is also called 
\emph on
derived table
\emph default
.
\end_layout

\end_deeper
\begin_layout Itemize
Row constructor - an expression that builds a row value (also known as composite
 value) using values for its member fields.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select row (1, 2.5, 'something');
\end_layout

\begin_layout Standard
or you can even use another table, for example:
\end_layout

\begin_layout Standard

\emph on
select row (t.*, 42) from t;
\emph default
 or 
\emph on
select row (t.f1, t.f2, 42) from t;
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Lateral 
\emph default
clause.
 It is used when we want to all record from relation X join result of some
 subquery, inside which is possible to use reference on relation X.
 For example, return sum of all positive numbers for each value, that are
 equals or smaller than this value:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select a, sum(i) from a, lateral generate_series(1, a) g(i) group by a order
 by 1;
\end_layout

\begin_layout Itemize
Subqueries appearing in 
\emph on
from
\emph default
 can be preceded by the key word 
\emph on
lateral
\emph default
.
 This allows them to reference columns provided by preceding 
\emph on
from
\emph default
 items.
 Without 
\emph on
lateral
\emph default
, each subquery is evaluated independently and so cannot cross-reference
 any other 
\emph on
from 
\emph default
item.
\end_layout

\begin_layout Itemize
A trivial example is:
\emph on
 select * from foo, lateral (select * from bar where bar.id = foo.bar_id)
 ss;
\emph default
 but of course, this can be written (and the functionality is the same)
 as 
\emph on
select * from foo, bar where bar.id = foo.bar_id;
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Insert 
\emph default
clause, for example with 
\emph on
update 
\emph default
and 
\emph on
on conflict.
 
\emph default
Here, we are using also 
\emph on
excluded
\emph default
 keyword, which represents row that makes collision.
 The following query inserts the content of table 
\emph on
boo
\emph default
 into table 
\emph on
foo
\emph default
.
 It does not do anything, if inserted value 
\emph on
x
\emph default
 is the same as existing one.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
insert into foo
\end_layout

\begin_layout Standard

\emph on
select *
\end_layout

\begin_layout Standard

\emph on
from boo
\end_layout

\begin_layout Standard

\emph on
on conflict (id) do
\end_layout

\begin_layout Standard

\emph on
update foo set x = excluded.x
\end_layout

\begin_layout Standard

\emph on
where x is distinct from excluded.x;
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
From
\emph default
 clause: A table reference can be:
\end_layout

\begin_deeper
\begin_layout Itemize
a table name (possibly schema-qualified),
\end_layout

\begin_layout Itemize
a derived table such as a subquery,
\end_layout

\begin_layout Itemize
a 
\emph on
join
\emph default
 construct,
\end_layout

\begin_layout Itemize
or a complex combinations of these.
\end_layout

\begin_layout Standard
If more than one table reference is listed in the 
\emph on
from 
\emph default
clause, the tables are cross-joined (that is, the Cartesian product of their
 rows is formed).
 The result of the 
\emph on
from 
\emph default
 list is an intermediate virtual table that can then be subject to transformatio
ns by the 
\emph on
where, group by, 
\emph default
and 
\emph on
having 
\emph default
clauses and is finally the result of the overall table expression.
\end_layout

\end_deeper
\begin_layout Itemize
Joining: they are specified with 
\emph on
noise words
\emph default
 in the syntax - 
\emph on
inner 
\emph default
and 
\emph on
outer 
\emph default
words, a 
\emph on
left, right, cross 
\emph default
(Cartesian product over the columns)
\emph on
, full
\emph default
 join is always an 
\emph on
outer 
\emph default
join, and a straight join always is an 
\emph on
inner 
\emph default
join.
 It is also possible to use a 
\emph on
natural
\emph default
 join, which automatically expand a join condition over columns having the
 same name.
 But in general, you should 
\series bold
avoid
\series default
 
\emph on
natural joins
\emph default
: you can (and will) change our query semantics by adding or removing a
 column from a table! There is also 
\emph on
cross join 
\emph default
and 
\emph on
lateral join
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize
It is widely considered good style to 
\series bold
qualify all column names 
\series default
in a join query, so that the query won't fail if a duplicate column name
 is later added to one of the tables.
\end_layout

\begin_layout Itemize
You can join with some condition:
\end_layout

\begin_deeper
\begin_layout Itemize
with clause 
\emph on
on
\emph default
: this takes a Boolean value expression of the same kind as is used in 
\emph on
where
\emph default
 clause.
\end_layout

\begin_layout Itemize
with clause 
\emph on
using
\emph default
: this allows you to take advantage of the specific situation where both
 sides of the join use the same name for joining column(s).
 It takes a comma-separated list of the shared column names and forms a
 join condition that includes an equality comparison for each one.
 For example, joining 
\emph on
T1
\emph default
 and 
\emph on
T2
\emph default
 with 
\emph on
using (a, b)
\emph default
 produces the join condition 
\emph on
on T1.a = T2.a and T1.b = T2.b
\emph default
.
\end_layout

\begin_layout Standard

\emph on
Natural
\emph default
 is a shorthand form of 
\emph on
using
\emph default
: it forms a 
\emph on
using 
\emph default
list consisting of all column names that appear in both input tables.
 As with 
\emph on
using
\emph default
, these columns appear only once in the output table.
 If there are no common column names, 
\emph on
natural join
\emph default
 behaves like 
\emph on
join 
\emph default
...
 
\emph on
on true 
\emph default
, producing a cross-product join.
\end_layout

\begin_layout Standard

\emph on
using
\emph default
 is reasonably safe from column changes in the joined relations since only
 the listed columns are combined.
 
\emph on
natural
\emph default
 is considerably more risky since any schema changes to either relation
 that cause a new matching column name to be present will cause the join
 to combine that new column as well.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Be careful when to use restriction during 
\emph on
join 
\emph default
clause.
 A restriction placed in the 
\emph on
on
\emph default
 clause is processed before the join, while a restriction placed in the
 
\emph on
where
\emph default
 clause is processed after the join.
 That does not matter with inner joins, but it matters a lot with outer
 joins.
\end_layout

\begin_layout Itemize
The join condition of an 
\emph on
inner join
\emph default
 can be written either in the 
\emph on
where 
\emph default
clause or in the 
\emph on
join 
\emph default
clause.
 For example, these table expressions are equivalent:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
from a, b where a.id = b.id and b.val > 5
\end_layout

\begin_layout Standard

\emph on
from a inner join b on (a.id = b.id) where b.val > 5
\end_layout

\begin_layout Standard

\emph on
from a natural join b where .val > 5
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Restricting: usually we are using 
\emph on
where
\emph default
 with 
\emph on
and 
\emph default
operator (
\emph on
or 
\emph default
operator exists but is more complex, especially with respect to indices).
 It is possible to use 
\emph on
case
\emph default
 logic statements if things are more complicated.
 There is also a support for 
\emph on
not 
\emph default
and 
\emph on
not in 
\emph default
(be careful with this one, especially with 
\emph on
NULL
\emph default
)
\emph on
.
 
\emph default
The following query returns no rows:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select x
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from generate_series(1,100) as t(x)
\end_layout

\begin_layout Standard

\emph on
where x not in (1, 2, 3, null);
\end_layout

\begin_layout Itemize
Anti-join pattern - possible thanks to special feature 
\emph on
not exists
\emph default
.
 It is meant to keep only the rows that fail a test.
 It is possible to use this in 
\emph on
where
\emph default
 with some nested 
\emph on
select 
\emph default
query.
 So, as an example, instead of the first query (very slow and inefficient,
 because RDBMS has to compare each row with an entire table of values),
 do anti-join (the second query, much faster as it matches up each row once,
 then simply eliminates the results that are not in the second table):
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select * from table t1 where t1.id not in (select id from table2)
\end_layout

\begin_layout Standard

\emph on
select * from table t1 left join table t2 on t1.id = t2.id where t2.id is null
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Aggregates - it is not possible to compute an aggregate over an aggregate.
 The solution is to compute them in separate 
\emph on
CTE 
\emph default
steps.
\end_layout

\begin_layout Itemize
Decorated literal expression - the use of variables with 
\backslash
set command:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description

\backslash
set start '2017-02-01'
\end_layout

\begin_layout Description
# and it will be available using :'start'
\end_layout

\begin_layout Description
date :'start'
\end_layout

\begin_layout Description
# is equal to
\end_layout

\begin_layout Description
date '2017-02-01'
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize

\emph on
Distinct on
\emph default
 - this keeps only the first row of each set of rows there the given expressions
 evaluate to equal.
 The first row of each set is unpredictable unless 
\emph on
order by 
\emph default
is used to ensure that the desired row appears first.
\end_layout

\begin_deeper
\begin_layout Itemize
Since 
\emph on
null 
\emph default
is a very special value, 
\emph on
is distinct from
\emph default
 and 
\emph on
is not distinct from
\emph default
 both pretend, that 
\emph on
null 
\emph default
is the same thing as 
\emph on
null.
\end_layout

\begin_layout Itemize
For example, 
\emph on
true = true 
\emph default
is 
\emph on
true
\emph default
, but 
\emph on
true = null
\emph default
 is 
\emph on
null.
 However, true is not distinct from true
\emph default
 is also 
\emph on
true, 
\emph default
but 
\emph on
true is not distinct from null
\emph default
 is 
\emph on
false, 
\emph default
and 
\emph on
true is distinct from true
\emph default
 results in 
\emph on
true.
\end_layout

\end_deeper
\begin_layout Itemize
Query returning some rows that match JSON criteria for a given type, artist,
 and colors key, all as a pretty printed JSON document (the @> operator
 reads 
\bar under
contains
\bar default
 and implements JSON searches, with support from a specialized GIN index
 if one has been created):
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
select jsonb_pretty(data)
\end_layout

\begin_layout Description
from magic.cards
\end_layout

\begin_layout Description
where data @> '{
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

:
\begin_inset Quotes erd
\end_inset

Enchantment
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

artist
\begin_inset Quotes erd
\end_inset

:
\begin_inset Quotes erd
\end_inset

Jim Murray
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

colors
\begin_inset Quotes erd
\end_inset

:[
\begin_inset Quotes eld
\end_inset

White
\begin_inset Quotes erd
\end_inset

]}';
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Set variable's value from CLI and run from bash:
\end_layout

\begin_deeper
\begin_layout Standard
\begin_inset Box Boxed
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "100col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status collapsed

\begin_layout Description
psql --variable "n=10" -f file_with_query.sql database_name
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
With select, it is possible to return computed values (here we use 
\emph on
format
\emph default
 function, but we could use 
\emph on
forename 
\emph default
|| ' ' || surname as fullname instead - PostgreSQL has operator 
\emph on
||
\emph default
 for concatenation) and to rename columns (aliases):
\end_layout

\begin_deeper
\begin_layout Standard
select code,
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

format('%s %s', forename, surname) as fullname,
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

forename,
\end_layout

\begin_layout Standard
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

surname as fullname
\end_layout

\begin_layout Standard
from drivers;
\end_layout

\end_deeper
\begin_layout Itemize
Alias can be any string, not just some named 'constant'.
\end_layout

\begin_layout Itemize

\emph on
Group by
\emph default
 - allows implementing much the same thing as map/reduce in other systems
 - map your data into different groups, and in each group reduce the data
 set to a single value.
 It is similar to 
\emph on
distinct
\emph default
, but 
\emph on
group by 
\emph default
is used on aggregate functions and 
\emph on
distinct
\emph default
 is more lightweight and used for a single values.
 For computation of several groups in parallel, you can use 
\emph on
grouping sets 
\emph default
feature used with 
\emph on
group by
\emph default
.
 Without this, there is a restriction with classic aggregates - you can
 run them through a single group definition at a time.
 Thanks to the 
\emph on
grouping sets
\emph default
 feature, we can run aggregates over more than one group at a time within
 a single query scan.
 Clause 
\emph on
rollup
\emph default
 generates permutation for each column of the 
\emph on
grouping sets
\emph default
 one after the other.
 Another kind of grouping sets clause shortcut is named 
\emph on
cube
\emph default
, which extends to all permutations available, including partial ones.
\end_layout

\begin_layout Itemize

\emph on
Having 
\emph default
- restricted selected groups.
 So this is some kind of 
\begin_inset Quotes eld
\end_inset

where
\begin_inset Quotes erd
\end_inset

 clause, operating on groups of data (aggregating functions).
 For example:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select city, max(temp_lo)
\end_layout

\begin_layout Standard

\emph on
from weather
\end_layout

\begin_layout Standard

\emph on
where city like 'S%'
\end_layout

\begin_layout Standard

\emph on
group by city
\end_layout

\begin_layout Standard

\emph on
having max(temp_lo) < 40;
\end_layout

\begin_layout Itemize
Difference between 
\emph on
where
\emph default
 and 
\emph on
having 
\emph default
is this:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
where 
\emph default
selects input rows before groups and aggregates are computed (thus, it controls
 which rows go into the aggregate computation).
\end_layout

\begin_layout Itemize

\emph on
having 
\emph default
selects group rows after groups and aggregates are computed.
\end_layout

\begin_layout Itemize
Thus, the 
\emph on
where
\emph default
 clause must not contain aggregate functions; it makes no sense to try to
 use an aggregate to determine which rows will be inputs to the aggregates.
 On the other hand, the 
\emph on
having
\emph default
 clause always contains aggregate functions (it is possible, but almost
 always useless).
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Union - you can assemble a result set from the result of several queries.
 For better readability, you can use parentheses of the union branches;
 but it is not required to do so.
 There is 
\emph on
union all
\emph default
 which is faster and does not filter out duplicated records.
 Another operations like this are 
\emph on
intersect
\emph default
 and 
\emph on
except.
 
\emph default
The result sometimes must be sorted, but it depends on your use-case.
\end_layout

\begin_layout Itemize

\emph on
Except 
\emph default
operator - computes a difference between two result sets.
 You can implement some regression tests with this operator very easily
 - if the data returned by two different queries are same, then there is
 zero records and the test would pass.
\end_layout

\begin_layout Itemize
The result of a 
\emph on
from
\emph default
 clause is a relation, which the query planner is executing the rest of
 your query: the 
\emph on
where
\emph default
 clause to restrict the relation dataset to what's interesting for the query,
 and other clauses, up until the 
\emph on
window function
\emph default
s and the 
\emph on
select projection
\emph default
 are computed so that we can finally construct the result set, i.e.
 a relation.
 The PostgreSQL optimizer will then re-arrange the computations needed so
 they’re as efficient as possible, rather than doing things in the way they
 are written.
\end_layout

\begin_layout Itemize

\emph on
Joins
\emph default
 are the basic operations you do with relations.
 The nature of a join is to build a new relation from a pair of existing
 ones.
 
\series bold
The key here is to remember that a join takes two relations and a join condition
 as input and it returns another relation.
 
\series default
A relation here is a bag of rows (this is a technical detail; it is not
 set as defined in math theory, because it could not have duplicated records)
 that all share a common relation data type definition, known at query planning
 time.
 For speed, it is needed to have indices on columns that are being joined
 together, and they must have the same type.
 Otherwise, there will be conversion of types on each row, which is not
 cheap.
 Summary of 
\emph on
joins
\emph default
:
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
Inner joins 
\emph default
are useful when you want to only keep rows that satisfy the 
\emph on
join condition 
\emph default
for both involved relation.
 It is basically a cross join with applicated predicate on it (predicate
 is an expression returning true or false).
\end_layout

\begin_layout Itemize

\emph on
Outer joins
\emph default
 - they are meant to preserve rows from your reference relation and add
 to it columns from the outer relation when the join condition is satisfied.
 When the join condition is not satisfied, the outer joins then fill the
 columns from the outer relation with 
\emph on
null
\emph default
 values.
 In other words, they are useful when you want to keep a reference relation's
 dataset no matter what and enrich it with the dataset from the other relation
 when the join condition is satisfied.
 The relation what you want to keep all the rows is pointed to in the name
 of the outer join - so left-hand side in a 
\emph on
left join.

\emph default
 When the 
\emph on
join condition
\emph default
 is not satisfied, it means you keep some known data and must fill in the
 result relation with data that doesn't exist, so that’s when 
\emph on
null
\emph default
 is very useful, and also why 
\emph on
null
\emph default
 is a member of every SQL data type (including the Boolean data type).
 By the way, 
\emph on
left join
\emph default
 can be more optimal than 
\emph on
right join
\emph default
, and in some database systems, 
\emph on
right join
\emph default
 is not even implemented.
\end_layout

\begin_layout Itemize

\emph on
Full outer joins
\emph default
 - this is a special case of an outer 
\emph on
join 
\emph default
where you want to keep all the rows in the dataset, whether they satisfy
 the 
\emph on
join condition
\emph default
 or not.
\end_layout

\begin_layout Itemize

\emph on
Lateral joins 
\emph default
- these introduce the capability for the 
\emph on
join condition
\emph default
 to be 
\emph on
pushed down
\emph default
 into the relation on the right, allowing for new semantics such as top-N
 queries, thanks to being able to use 
\emph on
limit 
\emph default
in a lateral subquery.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

Self
\begin_inset Quotes erd
\end_inset


\emph on
 join
\emph default
 - these are handy when you have rows that need to reference other rows
 in that same table.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.citusdata.com/blog/2019/01/02/fun-with-sql-self-joins/}}
\end_layout

\end_inset

 For example:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create table giftnames as ( id serial, name text, assignment int );
\end_layout

\begin_layout Standard

\emph on
select giver.name || ' is buying for ' || receiver.name
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from giftnames as giver, giftnames as receiver
\end_layout

\begin_layout Standard

\emph on
where giver.assignment = receiver.id;
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
The statements 
\emph on
insert, update, 
\emph default
and 
\emph on
delete 
\emph default
have something in common: they all accept a 
\emph on
returning
\emph default
 clause.
 This allows the 
\emph on
DML
\emph default
 command to return a result set to the application with the same protocol
 as the 
\emph on
select
\emph default
 clause, both are a 
\emph on
projection
\emph default
.
\end_layout

\begin_layout Itemize
The 
\emph on
update 
\emph default
statement in PostgreSQL works by: 
\emph on
insert
\emph default
 a new data and 
\emph on
delete 
\emph default
the old one.
 PostgreSQL system columns 
\emph on
xmin 
\emph default
and 
\emph on
xmax
\emph default
 allow visibility tracking of the rows so that concurrent statement have
 a consistent snapshot of the server's data set at all times.
 As 
\series bold
row locking is done per-tuple in PostgreSQL
\series default
, an 
\emph on
update
\emph default
 statement only ever blocks another 
\emph on
update, delete 
\emph default
or
\emph on
 select 
\emph default
for
\emph on
 update
\emph default
 statement 
\series bold
that targets the same row(s).
 So, 
\emph on
update 
\emph default
does not block 
\emph on
select
\emph default
.
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
HOT update (heap only tuple) 
\series default
is an internal thing of PostgreSQL.
 It is an optimization Postgres uses to reduce the amount of I/O necessary
 for updates.
 It creates a new update tuple if possible on the same page as the old tuple,
 and maintaining a chain of updated tuples linking a new version to the
 old tuple.
\end_layout

\begin_layout Itemize
The idea behind HOT is relatively simple.
 When updating a row, if it is possible, Postgres will place the new copy
 of the row right next to the old copy of the row.
 By doing this and marking the old copy row so that Postgres knows the new
 copy of the row is right next it, Postgres can avoid updating all of the
 indices.
 During an index scan in which the new copy of the row satisfies the filter,
 Postgres will encounter the old copy of the row.
 Since the old copy has been specially marked, Postgres will know the new
 copy is right next to it and can use that instead.
 This way, Postgres can pretend that all of the indices point to the new
 copy of the row, without ever needing to modify the indices.
\end_layout

\begin_layout Itemize
HOT updates can only reuse dead tuples from the previous transactions directly,
 not from the same or concurrent ones.
 HOT updates only work when the changed columns are not involved in indices
 in any way because the indices pointing the the old tuples need to point
 to the new version of it as of transaction id.
\end_layout

\begin_layout Itemize
You can check if any HOT update is on table: 
\emph on
select pg_stat_get_tuples_hot_updated('some_table'::regclass::oid);
\end_layout

\end_deeper
\begin_layout Itemize
The
\emph on
 delete 
\emph default
statement allows 
\series bold
marking tuples for removal
\series default
.
 
\series bold
The actual removal of on-disk tuples happens with 
\emph on
vacuum
\series default
\emph default
, which the system runs in the background for you automatically thanks to
 its autovacuum daemon.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/routine-vacuuming.html
\backslash
#AUTOVACUUM}}
\end_layout

\end_inset

 PostgreSQL might also re-use the on-disk space for an 
\emph on
insert 
\emph default
statement as soon as the tuple isn't visible for any transaction anymore.
 It is possible to use a 
\emph on
join condition
\emph default

\begin_inset space ~
\end_inset

when deleting rows, which can be done with 
\emph on
using 
\emph default
clause.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/sql-delete.html}}
\end_layout

\end_inset

 When you have to delete almost all rows from the table, so you are keeping
 a few ones, then it is more efficient to create a table containing only
 the new rows and swap it with the old table:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
begin;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
create table new_name (like name including all);
\end_layout

\begin_layout Standard

\emph on
insert into new_name
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select <column list>
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from name
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

where <restrictions>;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
drop table name;
\end_layout

\begin_layout Standard

\emph on
alter table new_name rename to name;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\emph on
commit;
\end_layout

\begin_layout Itemize
In general, as soon as you remove most entries from your table, this method
 is going to be more efficient.
 The trouble with this is the level of locking required to run the 
\emph on
drop table
\emph default
 and the
\emph on
 alter table
\emph default
 statements.
 Those 
\emph on
DDL
\emph default
 require an 
\emph on
access exclusive lock
\emph default
 and will block any read and write traffic to both tables while they run.
 If you don't have slow hours or even off-hours, then it might not be feasible
 for you to use this trick.
\end_layout

\begin_layout Itemize
The good thing about 
\emph on
delete
\emph default
 and 
\emph on
vacuum
\emph default
 is that they can run in he middle of about any concurrent traffic.
\end_layout

\begin_layout Itemize

\emph on
Autovacuum
\emph default
 is very important, it iterates over the tables, and if it finds table with
 10% of changes, then a new process will be created with 
\emph on
analyze 
\emph default
command on a given table.
 If there is a table with 20% of changes, then a new process is spawned
 with 
\emph on
vacuum
\emph default
 command on a given table.
 The maximum number of processes that can be created by 
\emph on
autovacuum
\emph default
 is limited.
 
\series bold
It is needed to monitor whether this limit is sufficient - number of processes
 created by 
\emph on
autovacuum
\emph default
 cannot be on maximum on a long-term basis.
 
\series default
That would mean, that Postgres is not able to vacuum fast enough, and tables
 are being more and more bloated.
 Understanding what the triggers are for autovacuum (and why it might not
 run) can be important when things start to slow down.
\end_layout

\begin_layout Itemize
During 
\emph on
query planning, the optimizer 
\emph default
in PostgreSQL uses statistics and based on them, it chooses the specific
 query plan
\emph on
.
 
\emph default
There is a histogram of values and approximate number of rows to each column.
 If, however, statistics does not reflect real data, then the optimizer
 does not choose the most optimal plan.
 This problem can be easily identified - see 
\emph on
explain analyze
\emph default
, and there is a mismatch in the number of processed and real rows.
 Command 
\emph on
analyze 
\emph default
updates these statistics.
 It goes sequentially through a given table.
 This is automatically called by 
\emph on
autovacuum.
\end_layout

\end_deeper
\begin_layout Itemize
The 
\emph on
truncate
\emph default
 statement
\emph on
 - delete 
\emph default
all the rows.
 This is internally considered as 
\emph on
DDL 
\emph default
rather than
\emph on
 DML.
 
\emph default
It is a very efficient way to purge a table of all of its content at once,
 as it doesn't follow per-tuple MVCC system and will simply remove the data
 files on disk.
\end_layout

\begin_layout Description
Functions
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset

and
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset

Statements
\end_layout

\begin_layout Itemize
A lot of functions that process text: 
\emph on
substring(), overlay(), position(), trim()
\emph default
, or aggregates such as 
\emph on
string_agg()
\emph default
.
 Also 
\emph on
regular expression 
\emph default
functions such as 
\emph on
regexp_split_to_table()
\emph default
.
 Standard operators 
\emph on
like, ilike, 
\emph default
and 
\emph on
similar to.
 
\emph default
PostgreSQL embeds support for a full-blown 
\emph on
regular expression
\emph default
 matching engine.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/functions-matching.html
\backslash
#FUNCTIONS-POSIX-REGEXP}}
\end_layout

\end_inset

 The main operator implementing regexp is 
\begin_inset Formula $\sim$
\end_inset

, and then you find the derivatives for 
\emph on
not matching 
\emph default
and 
\emph on
match either case.

\emph default
 In total, we have 4 operators: 
\begin_inset Formula $\sim$
\end_inset

, 
\begin_inset Formula $!\sim$
\end_inset

, 
\begin_inset Formula $\sim*$
\end_inset

, and 
\begin_inset Formula $!\sim*$
\end_inset

 (where 
\begin_inset Formula $*$
\end_inset

 means case insensitive and 
\begin_inset Formula $!$
\end_inset


\emph on
 
\emph default
means 
\emph on
not
\emph default
).
 Note that PostgreSQL also supports indexing for regular expressions thanks
 to its trigram extension 
\emph on
pg_trgm
\emph default
.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/pgtrgm.html}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Pattern matching
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
like / ilike 
\emph default
operator
\end_layout

\begin_layout Itemize

\emph on
similar to 
\emph default
operator - similar to 
\emph on
like
\emph default
, except that it interprets the pattern using the SQL standard's definition
 of a regular expression.
 However, 
\emph on
similar to
\emph default
 supports much more pattern-matching metacharacters borrowed from POSIX
 regular expressions (such as 
\emph on
+, ?, {m}, {m, } 
\emph default
and so on, except dot character).
 Searches using 
\emph on
similar to
\emph default
 patterns have the same security hazards, since 
\emph on
similar to
\emph default
 provides many of the same capabilities as POSIX-style regular expressions.
\end_layout

\begin_layout Itemize
LIKE searches, being much simpler than the other two options, are safer
 to use with possibly-hostile pattern sources.
\end_layout

\begin_layout Itemize
posix-style regular expressions
\end_layout

\begin_layout Standard
An underscore (
\emph on
_
\emph default
) in pattern stands for (matches) any single character; a percent sign (
\emph on
%
\emph default
) matches any sequence of zero or more characters.
\end_layout

\begin_layout Standard

\emph on
like
\emph default
 pattern matching always covers the entire string.
 Therefore, if it's desired to match a sequence anywhere within a string,
 the pattern must start and end with a percent sign.
\end_layout

\begin_layout Standard
The operator 
\emph on
~~
\emph default
 is equivalent to 
\emph on
like
\emph default
, and 
\emph on
~~*
\emph default
 corresponds to 
\emph on
ilike
\emph default
.
 There are also
\emph on
 !~~
\emph default
 and 
\emph on
!~~*
\emph default
 operators that represent 
\emph on
not like
\emph default
 and 
\emph on
not ilike
\emph default
, respectively.
 Also, prefix operator 
\emph on
^@
\emph default
 and corresponding 
\emph on
starts_with
\emph default
 function covers cases when only searching by beginning of the string is
 needed.
\end_layout

\begin_layout Standard
Also, see functions 
\emph on
substring, regexp_replace, regexp_match, regexp_matches, regexp_split_to_table,
 regexp_split_to_array
\end_layout

\end_deeper
\begin_layout Itemize
Finally, when mentioning advanced string matching and the regular expression,
 we must also mention PostgreSQL’s implementation of a 
\series bold
full text search
\series default
 with support for 
\emph on
documents
\emph default
, advanced 
\emph on
text search queries, ranking, highlighting, pluggable parsers, dictionaries
\emph default
 and 
\emph on
stemmers, synonyms,
\emph default
 and 
\emph on
thesaurus
\emph default
.
 Additionally, it’s possible to configure all those pieces.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/textsearch.html}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Searching in text is possible with:
\end_layout

\begin_deeper
\begin_layout Itemize
fulltext searching with fulltext operator 
\emph on
@@.
\end_layout

\begin_layout Itemize

\emph on
like 
\emph default
predicate, that can be speed up with index with option 
\emph on
varchar_pattern_ops
\emph default
 (where character 
\emph on
%
\emph default
 is the last one, and be careful because this supports only 
\emph on
like,
\emph default
 not 
\emph on
ilike
\emph default
).
 For example, query 
\emph on
select * from cities where name like 'L%';
\emph default
 can use the following index: 
\emph on
create index on cities (name 
\series bold
varchar_pattern_ops
\series default
);
\end_layout

\begin_layout Itemize
regular expression, with operator 
\emph on
~ 
\emph default
or 
\emph on
~*
\emph default
 (case-insensitive variant).
\end_layout

\end_deeper
\begin_layout Itemize
For using indices on queries with predicate (i)like or regular expressions,
 there is so called trigram index (on a set of three characters, see the
 next example).
 You can create it with extension 
\emph on
pg_trgm
\emph default
, and options 
\emph on
gist_trgm_ops, 
\emph default
or
\emph on
 gist_gin_trgm_ops.
 
\emph default
For example:
\end_layout

\begin_deeper
\begin_layout Itemize
for the following queries: 
\emph on
select * from cities where name ilike '%ice%'; 
\emph default
or for query 
\emph on
select name from cities where name ~ '^Le[ic]';
\end_layout

\begin_layout Itemize
there can be used the following index: 
\emph on
create index on cities using gist (name gist_trgm_ops);
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
coalesce(a, b, c)
\emph default
 - returns the first value that is not null.
 This can be useful during selecting from some table when using 
\emph on
outer join.

\emph default
 Instead of 
\emph on
Null
\emph default
 values, there would be something defined with 
\emph on
coalesce
\emph default
, for example 
\emph on
select name, surname, coalesce(number, 0) ....
\end_layout

\begin_layout Itemize

\emph on
cast()
\emph default
 - transformation of one type to another stop with a step size of step.
 It is inclusive much like BETWEEN operator, so we exclude the first day
 of the next month with the expression 
\series bold
- interval '1 day'
\series default
.
\end_layout

\begin_layout Itemize

\emph on
CTE - common table expression 
\emph default
- the 
\emph on
WITH
\emph default
 part of the query.
 The PostgreSQL database optimizes each 
\emph on
with
\emph default
 query and the main statement independent of each other.
 If a 
\emph on
with
\emph default
 query is referred multiple times, some 
\series bold
databases cache
\series default
 (i.e.
 “materialize”) 
\series bold
its result to prevent double execution.
 
\series default
CTE in PostgreSQL is that the database will evaluate the query inside the
 CTE and store the results.
 
\begin_inset CommandInset href
LatexCommand href
name "Principle of least astonishment"
target "https://en.wikipedia.org/wiki/Principle_of_least_astonishment"
literal "false"

\end_inset

 suggests that refactoring a derived table into a with query should not
 have any side effects on performance.
 Databases generally obey this principle, although PostgreSQL represents
 a big exception.
 The ability of 
\emph on
with 
\emph default
here 
\emph on
is 
\emph default
to turn nesting into chaining.
 This is the way to make complex queries top-down readable.
 It sometimes makes sense to use 
\emph on
with
\emph default
 clause inside a 
\emph on
with
\emph default
 query.
 You are not limited to a global spaghetti with clause: syntactically, with
 is a prefix for the select keyword.
 Use it where it helps improving readability.
 However, the other side of this coin is that the optimizer is less able
 to push restrictions from the parent query down into a WITH query than
 an ordinary subquery.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://medium.com/@hakibenita/be-careful-with-cte-in-postgresql-fca5e24d2119
}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
For example, upsert implementation:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
with upsert as (update target t set c = s.c from source s where t.id = s.id
 returning s.id)
\end_layout

\begin_layout Standard

\emph on
insert into target
\end_layout

\begin_layout Standard

\emph on
select *
\end_layout

\begin_layout Standard

\emph on
from source s
\end_layout

\begin_layout Standard

\emph on
where s.id not in (
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select id
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from upsert
\end_layout

\begin_layout Standard

\emph on
)
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Data-modifying statements in 
\emph on
with
\end_layout

\begin_deeper
\begin_layout Itemize
are executed exactly once, and always to completion, independently of whether
 the primary query reads all (or indeed any) of their output.
 Notice that this is different from the rule for 
\emph on
select
\emph default
 in 
\emph on
with
\emph default
: as stated in the previous section, execution of a 
\emph on
select
\emph default
 is carried only as far as the primary query demands its output.
\end_layout

\begin_layout Itemize
usually have 
\emph on
returning
\emph default
 clauses (see Section 6.4), as shown in the example above.
 It is the output of the 
\emph on
returning
\emph default
 clause, not the target table of the data-modifying statement, that forms
 the temporary table that can be referred to by the rest of the query.
 If a data-modifying statement in 
\emph on
with
\emph default
 lacks a 
\emph on
returning
\emph default
 clause, then it forms no temporary table and cannot be referred to in the
 rest of the query.
 Such a statement will be executed nonetheless.
\end_layout

\end_deeper
\begin_layout Itemize
The sub-statements in 
\emph on
with
\emph default
 are executed concurrently with each other and with the main query.
 Therefore, when using data-modifying statements in 
\emph on
with
\emph default
, the order in which the specified updates actually happen is unpredictable.
 All the statements are executed with the same snapshot, so they cannot
 “see” one another effects on the target tables.
 This alleviates the effects of the unpredictability of the actual order
 of row updates, and means that 
\emph on
returning
\emph default
 data is the only way to communicate changes between different 
\emph on
with
\emph default
 sub-statements and the main query.
\end_layout

\begin_layout Itemize
For example, the outer 
\emph on
select 
\emph default
would return the original prices before the action of the 
\emph on
update:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
with t as ( update products set price = price * 1.05 returning * )
\end_layout

\begin_layout Standard

\emph on
select * from products;
\end_layout

\end_deeper
\begin_layout Itemize
By the way, 
\series bold
CTE inlining
\series default
 is when the query optimizer decides to inline a CTE as a subquery which,
 as we've seen above, makes it possible to push the predicate.
 PostgreSQL is not inlining CTEs.
 
\series bold
Predicate push down
\series default
 means that the query optimizer can move predicates around based on logical
 rules in order generate better execution plans.
\end_layout

\begin_layout Itemize

\emph on
Recursive CTE 
\emph default
- an example here, including how deep recursion should maximally go:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
with recursive os as (select , 1 as deep from employees where id = 1 union
 all select z.*, deep + 1 from employee z join os on z.superior = os.id)
\end_layout

\begin_layout Standard

\emph on
select * from os;
\end_layout

\begin_layout Standard

\emph on
grouping sets
\end_layout

\end_deeper
\begin_layout Itemize
Split a CSV record saved as one column can be achieved by using 
\emph on
regexp_split_to_table(some_column, ',')
\emph default
.
 Interesting can be also function 
\emph on
regexp_split_to_array().
\end_layout

\begin_layout Itemize

\emph on
case - conditional expressions
\emph default
 (by the way, 
\emph on
<result>
\emph default
 may contain another 
\emph on
case
\emph default
):
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
case when <condition> then result
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

[when <condition> then result]
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

[else <result>]
\end_layout

\begin_layout Standard

\emph on
end
\end_layout

\begin_layout Itemize
SQL uses the order in which the conditions appear in the case expression
 to define their precedence.
 Put simply: case expressions evaluate to the 
\emph on
<result>
\emph default
 of the first true 
\emph on
<condition>
\emph default
.
\end_layout

\begin_layout Itemize
Do not use non-deterministic functions or data-changing functions in case
 expressions.
 The undefined evaluation process can have unpredictable side effects.
\end_layout

\begin_layout Itemize
Avoid mixing types in the then clauses.
 If needed, use cast to explicitly convert them to the required type.
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
array_length()
\emph default
 and 
\emph on
array_agg()
\end_layout

\begin_layout Itemize

\emph on
generate_series()
\end_layout

\begin_layout Itemize
If sorting is not chosen, the rows will be returned in an unspecified order.
 The actual order in that case will depend on the scan and join plan types
 and the order on disk, but it must not be relied on.
 A particular output ordering can only be guaranteed if the sort step is
 explicitly chosen.
\end_layout

\begin_layout Itemize
Note that the ordering options are considered independently for each sort
 column.
 For example 
\emph on
order by 
\emph default
x, y 
\emph on
desc 
\emph default
means 
\emph on
order by 
\emph default
x asc, y 
\emph on
desc
\emph default
, which is not the same as 
\emph on
order by x desc, y desc.
\end_layout

\begin_layout Itemize

\emph on
extract('isodow' from date) 
\emph default
- a standard SQL feature that allows computing the day of a week following
 the ISO rules.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
extract(<field> from <expression>)
\end_layout

\begin_layout Itemize
where 
\emph on
<field> 
\emph default
can be 
\emph on
year, month, day, hour, minute, second, timezone_hour, 
\emph default
or 
\emph on
timezone_minute.
\end_layout

\end_deeper
\begin_layout Itemize
See the implementation of database function:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select oid from pg_proc where proname = 'fu'; - - let's say that the results
 is 16389
\end_layout

\begin_layout Standard

\emph on
select pg_get_functiondef(16389);
\end_layout

\end_deeper
\begin_layout Itemize
Determination of age from the date of birth:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select extract(year from age('1972-08-20'::date));
\end_layout

\end_deeper
\begin_layout Itemize
Like against a list of value:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
where column ~~* any(array['%something%', '%somethingelse']));
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
date_trunc()
\end_layout

\begin_layout Itemize

\emph on
initcap()
\end_layout

\begin_layout Itemize

\emph on
replace()
\end_layout

\begin_layout Itemize

\emph on
pg_column_size() 
\emph default
- calculate size (in bytes) of a given column.
\end_layout

\begin_layout Itemize

\emph on
to_char()
\emph default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/11/functions-formatting.html}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Aggregate functions
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/functions-aggregate.html}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
They compute a single result from a set of input values.
\end_layout

\begin_layout Itemize
See functions 
\emph on
array_agg(), avg(), count(), every(), json_agg(), json_object_agg(), min(),
 max(), string_agg(), sum(), 
\emph default
and many others
\emph on
.
 
\emph default
It should be noted that except for 
\emph on
count
\emph default
, these functions return a null value when no rows are selected.
\end_layout

\end_deeper
\begin_layout Itemize
Window functions
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/tutorial-window.html} and 
\backslash
url{https://www.postgresql.org/docs/current/functions-window.html}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Also known as 
\emph on
analytic functions.
\end_layout

\begin_layout Itemize
They perform a calculation across a set of table rows that are somehow related
 to the current row.
 Window functions do not cause rows to become grouped into a single output
 row like non-window aggregate calls would.
 Instead, the rows retain their separate identities.
\end_layout

\begin_layout Itemize
An example that shows how to compare each employee's salary with the average
 salary in his or her department:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/tutorial-window.html}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select depname, empno, salary, avg(salary) over (partition by depname)
\end_layout

\begin_layout Standard

\emph on
from empsalary;
\end_layout

\begin_layout Standard
The fourth column 
\emph on
avg(salary)
\emph default
 represents an average taken across all the table rows that have the same
 depname value as the current row.
 This actually is the same function as the non-window 
\emph on
avg
\emph default
 aggregate, but the 
\emph on
over
\emph default
 clause causes it to be treated as a window function and computed across
 the window frame.
\end_layout

\end_deeper
\begin_layout Itemize
You can also control the order in which rows are processed by window functions
 using 
\emph on
order by 
\emph default
within 
\emph on
over:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select depname, empno, salary, rank() over (partition by depname order by
 salary desc)
\end_layout

\begin_layout Standard

\emph on
from empsalary;
\end_layout

\begin_layout Standard
The 
\emph on
rank
\emph default
 function produces a numerical rank for each distinct 
\emph on
order by
\emph default
 value in the current row's partition, using the order defined by the 
\emph on
order by
\emph default
 clause.
 rank needs no explicit parameter, because its behavior is entirely determined
 by the 
\emph on
over
\emph default
 clause.
\end_layout

\end_deeper
\begin_layout Itemize
See the difference between the following 2 queries:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select salary, sum(salary) over (order by salary) from empsalary;
\end_layout

\begin_layout Standard

\emph on
select salary, sum(salary) over () from empsalary;
\end_layout

\begin_layout Standard

\emph on
order by
\emph default
 can be omitted if the ordering of rows is not important.
 It is also possible to omit partition by, in which case there is a single
 partition containing all rows.
 For each row, there is a set of rows within its partition called its window
 frame.
 Some window functions act only on the rows of the window frame, rather
 than of the whole partition.
 By default, if 
\emph on
order by
\emph default
 is supplied then the frame consists of all rows from the start of the partition
 up through the current row, plus any following rows that are equal to the
 current row according to the 
\emph on
order by 
\emph default
clause.
 When 
\emph on
order by 
\emph default
is omitted the default frame consists of all rows in the partition.
\end_layout

\end_deeper
\begin_layout Itemize
Instead of using clause 
\emph on
group by 
\emph default
(as in 
\emph on
aggregation functions
\emph default
), there you are typically use 
\emph on
partition
\emph default
 clause.
\end_layout

\begin_layout Itemize
The whole idea behind 
\emph on
window functions
\emph default
 is to allow you to process several values of the result set at a time:
 you see through the window some peer rows and you are able to compute a
 single output value from them, much like when using an 
\emph on
aggregate function.
\end_layout

\begin_layout Itemize
These performs calculation across a set of table rows that are somehow related
 to the current row.
 This is comparable to the type of calculation that can be done with an
 aggregate function.
 However, window functions do not cause rows to become grouped into a single
 output row like non-window aggregate calls would.
 Instead, the rows retain their separate identities.
 Behind the scenes, the window function is able to access more than just
 the current row of the query result.
\end_layout

\begin_layout Itemize
Example: 
\emph on
select depname, empno, salary, avg(salary) over(partition by depname) from
 empsalary;
\emph default
 will compute average values over depname.
 Using 
\emph on
rank() 
\emph default
function, it is possible to produce a numerical rank for each distinct 
\emph on
order by
\emph default
 value in the current row's partition, using the order defined by the 
\emph on
order by
\emph default
 clause: 
\emph on
select depname, empno, salary, rank() over (partition by depname order by
 salary desc) from empsalary;
\end_layout

\begin_layout Itemize

\emph on
lag() 
\emph default
and 
\emph on
lead() 
\emph default
can be also useful functions (returns a record before/after some row, wqith
 some offset).
\end_layout

\begin_layout Itemize
It is possible also to use 
\emph on
aggregate filter (where ...) as some_alias 
\emph default
in 
\emph on
select
\emph default
 part of a query.
 This allows us to update our computation only for those rows that pass
 the filter.
\end_layout

\begin_layout Itemize
Any 
\emph on
aggregate function
\emph default
 can be used against a window frame rather than a
\emph on
 grouping clause
\emph default
.
 This includes 
\emph on
sum, min, max, count, avg.

\emph default
 It is possible to use the 
\emph on
create aggregate
\emph default
 command to register your own custom aggregate.
 Any such custom aggregate can also be given a window frame definition to
 work on.
\end_layout

\begin_layout Itemize

\emph on
row_number() 
\emph default
window function gives us a number of the current row within its partition,
 counting from 1.
\end_layout

\begin_layout Itemize

\emph on
rank() 
\emph default
window function provides a rank of the current row with gaps, see also 
\emph on
dense_rank() 
\emph default
or 
\emph on
percent_rank() 
\emph default
functions.
\end_layout

\begin_layout Itemize

\emph on
ntile()
\emph default
 - integer ranging from 1 to the argument value, dividing the partition
 as equally as possible.
\end_layout

\begin_layout Itemize
The real magic of 
\emph on
window functions
\emph default
 is actually the frame of data they can see when using the 
\emph on
over() 
\emph default
clause.
 This frame is specified thanks to the 
\emph on
partition by 
\emph default
and 
\emph on
order by 
\emph default
clauses.
\end_layout

\begin_layout Itemize

\series bold
Use window functions
\series default
 whenever you want to compute values for each row of the result set and
 those computations depend on other rows within the same result set.
 A classic example is a marketing analysis of weekly results: you typically
 output both each day’s gross sales and the variation with the same day
 in comparison to the previous week.
\end_layout

\end_deeper
\begin_layout Itemize
Within Postgres you can 
\emph on
comment
\emph default
 either a table or a column within a table:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
comment on table opportunities is 'some comment for a given table';
\end_layout

\begin_layout Standard

\emph on
comment on column opportunities.deleted_at is 'some text for this column';
\end_layout

\end_deeper
\begin_layout Itemize
Function that generates random timestamp (with time zones) entries from
 some range:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create or replace function random
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

a timestamptz,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

b timestamptz
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

)
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

returns timestamptz
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

volatile
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

language sql
\end_layout

\begin_layout Standard

\emph on
as $$
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select a
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

+ random(0, extract(epoch from (b-a))::int)
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

* interval '1 sec';
\end_layout

\begin_layout Standard

\emph on
$$;
\end_layout

\end_deeper
\begin_layout Itemize
Function that generates random integer from some range:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create or replace function random(a int, b int)
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

returns int
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

volatile
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

language sql
\end_layout

\begin_layout Standard

\emph on
as $$
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select a + ((b-a) * random())::int;
\end_layout

\begin_layout Standard

\emph on
$$;
\end_layout

\end_deeper
\begin_layout Itemize

\emph on
cardinality() 
\emph default
- for determining total number of elements in an array across all dimensions.
\end_layout

\begin_layout Itemize
Searching in arrays - can be done with a certain indexes (with 
\emph on
where 
\emph default
clause), or with 
\emph on
any, all,
\emph default
 or oher functions.
 You can also search for specific values in an array using the 
\emph on
array_position 
\emph default
and
\emph on
 array_positions
\emph default
 functions.
 The former returns the subscript of the first occurrence of a value in
 an array; the latter returns an array with the subscripts of all occurrences
 of the value in the array.
\end_layout

\begin_deeper
\begin_layout Itemize
There are some array operators worth to know, such as 
\emph on
=, <>, <, >, <=, >=, @> 
\emph default
(contains),
\emph on
 <@ 
\emph default
(is contained by)
\emph on
, && 
\emph default
(overlap - have elements in common)
\emph on
, ||
\emph default
 (contatenation).
\end_layout

\begin_layout Itemize
Also, a lot of useful functions are there: 
\emph on
array_append, array_cat 
\emph default
(concatenation)
\emph on
, array_ndims, array_dims, array_fill 
\emph default
(initialization of array with certain values and dimension)
\emph on
, array_length, cardinality, unnest, string_to_array, array_replace 
\emph default
(replacing each element in an array equal to the given value with a new
 value)
\emph on
, array_remove 
\emph default
(remove all elements equal to the given value from the array (array must
 be one-dimensional)
\emph on
, array_prepend 
\emph default
(append an element to the beginning of an array)
\emph on
, array_position, array_positions,
\emph default
 and others.
\end_layout

\end_deeper
\begin_layout Itemize
When we want to 
\emph on
use a 
\emph default
kNN
\emph on
 
\emph default
search, we can do that with 
\emph on
clause order by ...
 <-> ...
 limit k
\emph default
.
 The operator 
\emph on
<-> 
\emph default
computes the distance in between its argument, and by using 
\emph on
limit 1
\emph default
 clause we select the nearest known entry.
\end_layout

\begin_layout Itemize
Select only random 1% of rows: 
\emph on
select * from some_table tablesample bernoulli(1); 
\emph default
So here, we used 
\emph on
tablesample 
\emph default
and we used 
\emph on
bernoulli, 
\emph default
but SQL standard defines also 
\emph on
system
\emph default
 as a sampling methods.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.2ndquadrant.com/en/blog/tablesample-in-postgresql-9-5-2/}}
\end_layout

\end_inset

 The 
\emph on
SYSTEM
\emph default
 method uses random IO whereas 
\emph on
BERNOULLI
\emph default
 uses sequential IO.
 
\emph on
SYSTEM
\emph default
 is faster, but 
\emph on
BERNOULLI
\emph default
 gives us a much better random distribution because each tuple (row) has
 the same probability on being selected.
 The SYSTEM sampling method does block/page level sampling; it reads and
 returns random pages from disk.
 Thus it provides randomness at the page level instead of the tuple level.
 The BERNOULLI sampling method does a sequential scan on the whole table
 and picks tuples randomly.
 This 
\emph on
tablesample 
\emph default
can be usefull for exploratory research where TABLESAMPLE can help to quickly
 identify areas for further study.
 Sometimes (fast prototyping for example) we want to use just a small part
 of table / database.
\end_layout

\begin_layout Itemize
PostgreSQL allows functions that have named parameters to be called using
 either
\emph on
 positional, named, 
\emph default
or
\emph on
 mixed
\emph default
 notation.
 Let's define a function: 
\emph on
create function concat_lower_or_upper(a text, b text, uppercase boolean
 defalt false)
\end_layout

\begin_deeper
\begin_layout Itemize

\emph on
positional
\emph default
 
\emph on
notation
\emph default
: for example (but we can ommit the last 'true' for instance):
\emph on
 select concat_lower_or_upper('Hello', 'World', true);
\end_layout

\begin_layout Itemize

\emph on
named notation
\emph default
: for example, we can use it like this: 
\emph on
select concat_lower_or_upper(a => 'Hello', b => 'World'); 
\emph default
By the way, an older syntax based on 
\emph on
":=" 
\emph default
is supported for backward compatibility (instead of 
\emph on
"=>"
\emph default
).
\end_layout

\begin_layout Itemize

\emph on
mixed notation
\emph default
: this combines 
\emph on
positional
\emph default
 and 
\emph on
named
\emph default
 notation.
 In this case, positional parameters are written first and named parameters
 appear after them: 
\emph on
select concat_lower_or_upper('Hello', 'World', uppercase => true);
\end_layout

\end_deeper
\begin_layout Description
Extensions
\end_layout

\begin_layout Itemize
Extensions generally fall into a few different broad categories
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://pgxn.org/}}
\end_layout

\end_inset

:
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Custom data types
\end_layout

\begin_layout Itemize

\series bold
Monitoring
\end_layout

\begin_layout Itemize

\series bold
New use cases/functionality
\end_layout

\begin_layout Itemize

\series bold
Foreign data wrappers
\end_layout

\end_deeper
\begin_layout Description
Full
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset

text
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\end_layout

\end_inset

search
\end_layout

\begin_deeper
\begin_layout Itemize
Full Text Searching (or just text search) provides the capability to identify
 natural-language documents that satisfy a 
\series bold
\emph on
query
\series default
\emph default
, and optionally to sort them by relevance to the 
\emph on
query
\emph default
.
\end_layout

\begin_layout Itemize
PostgreSQL has 
\emph on
~, ~*
\emph default
, 
\emph on
like
\emph default
, and 
\emph on
ilike 
\emph default
operators for textual data types, but they lack many essential properties
 required by modern information systems, such as linguistic support, handling
 derived words, some ordering, there is no proper index support (so they
 must process all documents for every search).
\end_layout

\begin_layout Itemize
Full text indexing allows documents to be preprocessed and an index saved
 for later rapid searching.
 Preprocessing includes:
\end_layout

\begin_deeper
\begin_layout Itemize
Parsing documents into tokens.
\end_layout

\begin_layout Itemize
Converting tokens into lexemes (lexem is a string, just like a token, but
 normalized, so that different forms of the same word are made alike).
\end_layout

\begin_layout Itemize
Storing preprocessed documents optimized for searching.
\end_layout

\end_deeper
\begin_layout Itemize
You can also define stop words, map phrases to a single word using a thesaurus,
 use stemming, and a lot of other things.
\end_layout

\begin_layout Itemize

\series bold
A data type 
\emph on
tsvector
\emph default
 is provided for storing preprocessed documents, along with a type 
\emph on
tsquery
\emph default
 for representing processed queries.
\end_layout

\begin_layout Itemize
Full text searching in PostgreSQL is based on the match operator 
\series bold
\emph on
@@
\series default
\emph default
, which returns 
\emph on
true
\emph default
 if a 
\emph on
tsvector
\emph default
 (document) matches a 
\emph on
tsquery
\emph default
 (query).
\end_layout

\begin_layout Itemize
There are functions 
\emph on
to_tsquery
\emph default
, 
\emph on
plainto_tsquery,
\emph default
 and 
\emph on
phraseto_tsquery
\emph default
 that are helpful in converting user-written text into a proper 
\emph on
tsquery
\emph default
, primarily by normalizing words appearing in the text.
 Similarly, t
\emph on
o_tsvector 
\emph default
is used to parse and normalize a document string.
 This is much better in practise than using explicit conversion: 
\emph on
'some text'::tsvector
\emph default
, because this does not perform any normalization of words.
 The elements of a 
\emph on
tsvector
\emph default
 are lexemes, which are assumed to be already normalized.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat & rat');
\end_layout

\end_deeper
\begin_layout Itemize
There are operators such as 
\emph on
and (&) 
\emph default
and 
\emph on
or (|)
\emph default
, and 
\emph on
not (!)
\emph default
.
 For example, the following query:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
fat & ! rat 
\emph default
matches documents that contain 
\emph on
fat 
\emph default
but not 
\emph on
rat.
\end_layout

\end_deeper
\begin_layout Itemize
Searching for phrases is possible with the help of the 
\emph on
<-> (followed by) tsquery
\emph default
 operator, which matches only if its arguments have matches that are adjacent
 and in the given order:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select to_tsvector('fatal error') @@ to_tsquery('fatal <-> error'); - -
 this gives true
\end_layout

\begin_layout Standard

\emph on
select to_tsvector('error is not fatal') @@ to_tsquery('fatal <-> error');
 - - this gives false
\end_layout

\begin_layout Standard
There is a more general version of the 
\emph on
followed by
\emph default
 operator having the form 
\emph on
<N>
\emph default
, where 
\emph on
N
\emph default
 is an integer standing for the difference between the positions of the
 matching lexemes.
 So 
\emph on
<-> 
\emph default
operator is the same as 
\emph on
<1>
\emph default
.
 A special case that's sometimes useful is that
\emph on
 <0>
\emph default
 can be used to require that two patterns match the same word.
\end_layout

\end_deeper
\begin_layout Itemize
Full text search functionality includes the ability to do many more things:
 skip indexing certain words (stop words), process synonyms, and use sophisticat
ed parsing, e.g., parse based on more than just white space.
 This functionality is controlled by text search configurations.
 PostgreSQL comes with predefined configurations for many languages, and
 you can easily create your own configurations (psql's
\emph on
 
\backslash
dF 
\emph default
command shows all available configurations).
\end_layout

\begin_layout Itemize
Text search parses and templates are built from low-level C functions; therefore
 it requires C programming ability to develop new ones, and superuser privileges
 to install one into a database.
\end_layout

\end_deeper
\begin_layout Section
Some common problems from the past
\end_layout

\begin_layout Standard
These were gathered from some articles, my own experiences, other guys from
 my previous companies, and so on.
 I consider them worth noticing.
\end_layout

\begin_layout Subsection
Slow queries
\end_layout

\begin_layout Itemize
Do we need that query?
\end_layout

\begin_layout Itemize
Slow query is relative, but in some sources on the Internet, a query is
 considered to be slow when it runs for more than 200ms.
 Optimization is in 70% regarding adding indices, 20% in optimization of
 the query itself.
 and remaining 10% lies in changing the whole approach.
\end_layout

\begin_layout Itemize
Is the query waiting for lock or IO?
\end_layout

\begin_layout Itemize

\series bold
Adding an index won't always speed up a query.
\end_layout

\begin_layout Itemize
Hypothetical indices for PostgreSQL extension is worth to try - 
\begin_inset CommandInset href
LatexCommand href
name "hypopg"
target "https://github.com/HypoPG/hypopg"
literal "false"

\end_inset

.
\end_layout

\begin_layout Itemize

\series bold
Column order matters when creating an index.
 The first column should be a one on which the most expensive operation
 is!
\end_layout

\begin_layout Itemize

\series bold
Partial indices can improve performance but covers less use cases.
 
\series default
The idea is to increase the efficiency of the index by reducing its size.
 A smaller index takes less storage, is easier to maintain, and is faster
 to scan.
\end_layout

\begin_layout Itemize

\series bold
Sorting is more expensive than filtering.
\end_layout

\begin_layout Itemize
PostgreSQL's Query Planner behaves differently depending on the number of
 rows in the database.
\end_layout

\begin_layout Itemize
Set 
\emph on
effective_cache_size 
\emph default
to be 2/3 of RAM - based on this value, the PostgreSQL optimizer determines
 whether to choose sequential or index scan.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://postgres.cz/wiki/Desatero}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Number of connections to database - 10x CPUs is fine, 100x CPUs is not.
\end_layout

\begin_layout Subsection
Disks are full
\end_layout

\begin_layout Itemize
Can we remove some unnecessary indices?
\end_layout

\begin_layout Itemize
Can we deduplicate data in the tables?
\end_layout

\begin_layout Itemize
Are the tables unnecessarily bloated?
\end_layout

\begin_layout Subsection
Drives are overloaded
\end_layout

\begin_layout Itemize
Can we decrease sequential scans or full table index scans?
\end_layout

\begin_layout Itemize
Can we decrease temporary tables usage?
\end_layout

\begin_layout Itemize
Can we increase the throughput (RAID type, number of disks, ...)?
\end_layout

\begin_layout Itemize
Can we add RAM to give more disk cache to database?
\end_layout

\begin_layout Subsection
Anti-patterns and other common mistakes
\end_layout

\begin_layout Itemize
Column with a list of integer values instead of M:N table.
\end_layout

\begin_layout Itemize
Timestamp column without timezone.
\end_layout

\begin_layout Itemize
Using a wrong type of index - for example, using GIN index on jsonb column
 (which is perfectly fine), but for query using 
\emph on
where 
\emph default
clause
\emph on
 
\emph default
(a simple comparison) instead of operators such as 
\emph on
@>, <@, ->, ->>, 
\emph default
etc.

\emph on
 
\emph default
that works with various 
\emph on
jsonb
\emph default
 attributes.
 Thus, this index is never used!
\end_layout

\begin_layout Itemize
Always test your changes! With database, this is maybe even more true than
 testing application changes, since introducing sub-optimal behavior affects
 all components connecting to the database, not only application that uses
 your changes.
 When creating indices, always test if your query actually uses them and
 measure the speedup by:
\end_layout

\begin_deeper
\begin_layout Itemize
Using 
\emph on

\backslash
timing 
\emph default
command in 
\emph on
psql 
\emph default
to show times of each command executed.
\end_layout

\begin_layout Itemize
Using 
\emph on
explain analyze 
\emph default
to check time and if indices are used.
\end_layout

\end_deeper
\begin_layout Itemize
If you have multiple transactions that are concurrently executing 
\emph on
update
\emph default
 queries, make sure that they are all using the same order of updated rows,
 otherwise you will sooner or later encounter 
\series bold
\emph on
deadlock
\series default
\emph default
.
 
\series bold
Simply sort the input data so that all transactions modify row A before
 row B and not vice versa.
 The best defense against deadlocks is generally to avoid them by being
 certain that all applications using a database acquire locks on multiple
 objects in a consistent order.
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.postgresql.org/docs/current/explicit-locking.html}}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize

\series bold
Inserting a large amount of data
\end_layout

\begin_deeper
\begin_layout Itemize
When using multiple 
\emph on
insert
\emph default
 clauses, turn off 
\emph on
autocommit
\emph default
 and just do one commit at the end.
 In plain SQL, this means issuing 
\emph on
begin
\emph default
 at the start and 
\emph on
commit
\emph default
 at the end.
 Some client libraries might do this behind your back, in which case you
 need to make sure the library does it when you want it done.
 If you allow each insertion to be committed separately, PostgreSQL is doing
 a lot of work for each row that is added.
 An additional benefit of doing all insertions in one transaction is that
 if the insertion of one row were to fail then the insertion of all rows
 inserted up to that point would be rolled back, so you won't be stuck with
 partially loaded data.
\end_layout

\begin_layout Itemize
Use 
\emph on
copy 
\emph default
to load all the rows in one command, instead of using a series of 
\emph on
insert
\emph default
 commands.
 The 
\emph on
copy
\emph default
 command is optimized for loading large numbers of rows; it is less flexible
 than 
\emph on
insert
\emph default
, but incurs significantly less overhead for large data loads.
 Since 
\emph on
copy
\emph default
 is a single command, there is no need to disable autocommit if you use
 this method to populate a table.
\end_layout

\begin_layout Itemize
If you cannot use 
\emph on
copy
\emph default
, it might help to use 
\emph on
prepare 
\emph default
to create a prepared 
\emph on
insert
\emph default
 statement, and then use 
\emph on
execute
\emph default
 as many times as required.
 This avoids some of the overhead of repeatedly parsing and planning 
\emph on
insert
\emph default
.
 Note that loading a large number of rows using 
\emph on
copy
\emph default
 is almost always faster than using 
\emph on
insert
\emph default
, even if 
\emph on
prepare
\emph default
 is used and multiple insertions are batched into a single transaction.
\end_layout

\begin_layout Itemize
If you are loading a freshly created table, the fastest method is to create
 the table, bulk load the table's data using 
\emph on
copy
\emph default
, then create any indexes needed for the table.
 Creating an index on pre-existing data is quicker than updating it incrementall
y as each row is loaded.
\end_layout

\begin_layout Itemize
If you are adding large amounts of data to an existing table, it might be
 a win to drop the indexes, load the table, and then recreate the indexes.
 Of course, the database performance for other users might suffer during
 the time the indexes are missing.
 One should also think twice before dropping a unique index, since the error
 checking afforded by the unique constraint will be lost while the index
 is missing.
\end_layout

\begin_layout Itemize
Whenever you have significantly altered the distribution of data within
 a table, running 
\emph on
analyze
\emph default
 is strongly recommended.
 This includes bulk loading large amounts of data into the table.
 Running 
\emph on
analyze
\emph default
 (or 
\emph on
vacuum
\emph default
 
\emph on
analyze
\emph default
) ensures that the planner has up-to-date statistics about the table.
 With no statistics or obsolete statistics, the planner might make poor
 decisions during query planning, leading to poor performance on any tables
 with inaccurate or nonexistent statistics.
 Note that if the autovacuum daemon is enabled, it might run 
\emph on
analyze
\emph default
 automatically.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Parallel Queries
\end_layout

\begin_deeper
\begin_layout Itemize

\series bold
Query plans which can leverage multiple CPUs in order to answer queries
 faster.
\end_layout

\begin_layout Itemize
Many queries cannot benefit from parallel query, either due to limitations
 of the current implementation or because there is no imaginable query plan
 which is any faster than the serial query plan.
 However, for queries that can benefit, the speedup from parallel query
 is often very significant.
 Many queries can run more than twice as fast when using parallel query,
 and some queries can run four times faster or even more.
\end_layout

\begin_layout Itemize

\series bold
Queries that touch a large amount of data but return only a few rows to
 the user will typically benefit most.
\end_layout

\begin_layout Itemize
When the optimizer determines that parallel query is the fastest execution
 strategy for a particular query, it will create a query plan which includes
 a 
\emph on
Gather
\emph default
 or 
\emph on
Gather Merge
\emph default
 node.
 Using 
\emph on
explain 
\emph default
command, you can see also a number of workers chosen by the planner.
 It is possible for a parallel query to run with fewer workers than planned,
 or even with no workers at all (because of various limitations, that can
 be modified by the way).
\end_layout

\begin_layout Itemize
Every background worker process which is successfully started for a given
 parallel query will execute the parallel portion of the plan.
 The leader will also execute that portion of the plan, but it has an additional
 responsibility: it must also read all of the tuples generated by the workers.
 When the parallel portion of the plan generates only a small number of
 tuples, the leader will often behave very much like an additional worker,
 speeding up query execution.
 Conversely, when the parallel portion of the plan generates a large number
 of tuples, the leader may be almost entirely occupied with reading the
 tuples generated by the workers and performing any further processing steps
 which are required by plan nodes above the level of the Gather node or
 Gather Merge node.
 In such cases, the leader will do very little of the work of executing
 the parallel portion of the plan.
\end_layout

\begin_layout Itemize
No parallel query is possible, when your query writes/modifies any data,
 locks any database rows, or if a query is running inside of another query
 that is already parallel.
\end_layout

\begin_layout Itemize
Parallel query plans are not generated when the transaction isolation level
 is serializable.
\end_layout

\begin_layout Itemize
Because each worker executes the parallel portion of the plan to completion,
 it is not possible to simply take an ordinary query plan and run it using
 multiple workers.
 Each worker would produce a full copy of the output result set, so the
 query would not run any faster than normal but would produce incorrect
 results.
 Instead, the parallel portion of the plan must be what is known internally
 to the query optimizer as a partial plan; that is, it must be constructed
 so that each process which executes the plan will generate only a subset
 of the output rows in such a way that each required output row is guaranteed
 to be generated by exactly one of the cooperating processes.
 Generally, this means that the scan on the driving table of the query must
 be a parallel-aware scan.
\end_layout

\begin_layout Itemize
There is 
\emph on
parallel scan, parallel join, parallel aggregation, 
\emph default
and 
\emph on
parallel append 
\emph default
(when you implement union all or when scanning a partitioned table)
\emph on
.
\end_layout

\begin_layout Itemize
If a query that is expected to do so does not produce a parallel plan, you
 can try reducing parallel_setup_cost or parallel_tuple_cost.
 Of course, this plan may turn out to be slower than the serial plan which
 the planner preferred, but this will not always be the case.
 If you don't get a parallel plan even with very small values of these settings
 (e.g.
 after setting them both to zero), there may be some reason why the query
 planner is unable to generate a parallel plan for your query.
\end_layout

\end_deeper
\begin_layout Itemize
When you want to modify an existing table by adding a new column (in production
 especially), never specify a default value! Adding a column takes a very
 aggressive lock on the table, which blocks read and write.
 If you add a column with a default, PostgreSQL will rewrite the whole table
 to fill in the default for every row, which can take hours on large tables!
 In the meantime, all queries will block, so your database will be basically
 unavailable.
\end_layout

\begin_deeper
\begin_layout Itemize
So, instead of this: 
\emph on
alter table items add column last_update timestamptz default now();
\end_layout

\begin_layout Itemize
Do this: 
\emph on
alter table items add column last_update timestamptz; update items set last_upda
te = now();
\end_layout

\begin_layout Itemize
Or even better:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
do {
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

numRowsUpdated = executeUpdate(
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

"UPDATE items SET last_update = ? " +
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

"WHERE ctid IN (" +
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

" SELECT ctid FROM items WHERE last_update IS NULL LIMIT 5000" +
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

")",
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

now);
\end_layout

\begin_layout Standard

\emph on
} while (numRowsUpdated > 0);
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Take aggressive locks as late as possible.
\end_layout

\begin_deeper
\begin_layout Itemize
Do not do this:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
begin;
\end_layout

\begin_layout Standard

\emph on
-- reads and writes blocked from here:
\end_layout

\begin_layout Standard

\emph on
truncate items;
\end_layout

\begin_layout Standard

\emph on
-- long-running operation:
\end_layout

\begin_layout Standard

\emph on

\backslash
copy items from 'newdata.csv' with csv
\end_layout

\begin_layout Standard

\emph on
commit; 
\end_layout

\end_deeper
\begin_layout Itemize
Do this instead:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
begin;
\end_layout

\begin_layout Standard

\emph on
-- Use following line only if you must prevent writes to items
\end_layout

\begin_layout Standard

\emph on
-- lock items in exclusive mode;
\end_layout

\begin_layout Standard

\series bold
\emph on
create table items_new (like items including all);
\end_layout

\begin_layout Standard

\emph on
-- long-running operation:
\end_layout

\begin_layout Standard

\emph on

\backslash
copy items_new from 'newdata.csv' with csv
\end_layout

\begin_layout Standard

\emph on
-- reads and writes blocked from here:
\end_layout

\begin_layout Standard

\series bold
\emph on
drop table items;
\end_layout

\begin_layout Standard

\series bold
\emph on
alter table items_new rename to items;
\end_layout

\begin_layout Standard

\emph on
commit;
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize

\series bold
Never use 
\emph on
vacuum full
\series default
\emph default
 - it performs a full table copy, which can take ages for big tables.
 
\series bold
Applications should be designed not to ever create that much bloat to require
 
\emph on
vacuum full
\emph default
! However,
\series default
 according to Pavel Stehule, it is recommended to use 
\emph on
vacuum
\emph default
 once per a day, and 
\emph on
vacuum full
\emph default
 once per a month.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://postgres.cz/wiki/Desatero}}
\end_layout

\end_inset

 
\emph on
Vacuum full 
\emph default
locks the table, and it is something like defragmentation of files on disk.
 However, newer versions of PostgreSQL have 
\emph on
autovacuum.
 Vacuum 
\emph default
can be applied on a table, or on the whole database.
\end_layout

\begin_layout Itemize

\series bold
Do not use 
\emph on
is false 
\emph default
in 
\emph on
where 
\emph default
clause
\series default
.
 So, instead of 
\emph on
'...
 where something is false ...'
\emph default
 do 
\emph on
'...
 where not something ...'.
 
\emph default
The second query can be 15-20% faster, and they may have even identical
 execution plan.
\end_layout

\begin_layout Itemize

\series bold
Filter join tables in 
\emph on
join
\emph default
 clause whenever possible.
 
\series default
Queries in the following example give the same result, but the second one
 is faster because rows from table A are filtered even before they are joined
 with table B.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select * from A join B on A.id = B.id where A.need_revision -- way slower -
 makes complete join and filters the result
\end_layout

\begin_layout Standard

\emph on
select * from A join B on A.id = B.id and A.need_revision -- way faster - filters
 the source and joins only necessary rows from B.
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Use 
\emph on
except 
\emph default
to subtract rows from query result.
 
\series default
Let's assume that the table 
\emph on
entries
\emph default
 contains multiple rows with the same columns "
\emph on
hash
\emph default
", but with different columns "
\emph on
source
\emph default
" and contains approximately ten millions rows.
 You want to select the rows with source 44, but only those that don't belong
 also to source 62.
 First select takes hours to complete and cannot make use of indices, whereas
 the second one needs only around 300 milliseconds on properly indexed table
 (index on column "source" is sufficient).
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select value from entries where source = 44 and hash not in (select hash
 from entries where source = 62);
\end_layout

\begin_layout Standard

\emph on
select value from entries where source = 44 except select value from entries
 where source = 62;
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Minimize changes in tables that are source of reference integrity.
 
\series default
If you change a row in a table which is a source of many reference integrity
 constraints, you force lots of indices to be rebuilt, which is very expensive!
 For example, if you have table 
\emph on
users
\emph default
, it will naturally be a source of lots of RIs to other tables that reference
 users.
 DO NOT add field like 
\emph on
last_action
\emph default
 which you update with every web page load, because with each update you
 create new row, which creates table bloat, index bloat and you force all
 the reference integrity to update the indices! Create standalone table
 for actions log, which will not be referenced and contains minimum or no
 indices.
 If you need analytical output, create indices when they are needed or copy
 the table into another database and index it.
\end_layout

\begin_layout Itemize

\series bold
Database server should have RAM at least as big as 10% of active data in
 the database, but 200% for reasonably responsible web application!
\end_layout

\begin_layout Itemize

\series bold
Each 
\emph on
commit 
\emph default
calls
\emph on
 fsync - 
\emph default
minimize the amount of transactions as much as possible!
\end_layout

\begin_layout Itemize
You should set timeout to long-running transactions.
\end_layout

\begin_layout Itemize
Never use 
\emph on
count(*)
\emph default
 on big tables! Command 
\emph on
analyze verbose 
\emph default
gives you the number of lines in a few seconds instead of tens of minutes
 and you don't overload the database by sequential seek and loading of the
 whole table.
 Even if you work with small tables, use 
\emph on
count(0)
\emph default
 instead of
\emph on
 count(*)
\emph default
 because it is a constant expression! Normally, 
\emph on
count(*) 
\emph default
will perform a sequential scan of the table, which can be quite expensive.
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://www.cybertec-postgresql.com/en/count-made-fast/}}
\end_layout

\end_inset

 The 
\emph on
count(*)
\emph default
 is expanded to all columns.
 Writing 
\emph on
count(1)
\emph default
 is the same as 
\emph on
count(*)
\emph default
, but 
\emph on
count(id)
\emph default
 is something different: it will only count the rows where id 
\emph on
is not null
\emph default
, since most aggregates ignore 
\emph on
null
\emph default
 values.
 So, there is nothing to be gainer by avoiding the 
\emph on

\begin_inset Quotes eld
\end_inset

*
\begin_inset Quotes erd
\end_inset


\emph default
.
 If you really want to count rows in a big table, you can create another
 table for it, and write your own function in PL/PGSQL that will return
 a trigger.
 For example:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
start transaction;
\end_layout

\begin_layout Standard

\emph on
create table mytable_count(c bigint);
\end_layout

\begin_layout Standard

\emph on
create function mytable_count() returns trigger
\end_layout

\begin_layout Standard

\emph on
language plpgsql as
\end_layout

\begin_layout Standard

\emph on
$$begin
\end_layout

\begin_layout Standard

\emph on
if tg_op = 'insert' then
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

update mytable_count set c = c + 1;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return new;
\end_layout

\begin_layout Standard

\emph on
elsif tg_op = 'delete' then
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

update mytable_count set c = c - 1;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return old;
\end_layout

\begin_layout Standard

\emph on
else
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

update mytable_count set c = 0;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

return null;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

end if;
\end_layout

\begin_layout Standard

\emph on
end;$$;
\end_layout

\begin_layout Standard

\emph on
create constraint trigger mytable_count_mod after insert or delete on mytable
 deferrable initially deferred for each row execute procedure mytable_count();
\end_layout

\begin_layout Standard

\emph on
-- truncate triggers must be for each statement
\end_layout

\begin_layout Standard

\emph on
create trigger mytable_count_trunc after truncate on mytable for each statement
 execute procedure mytable_count();
\end_layout

\begin_layout Standard

\emph on
-- initialize the counter table
\end_layout

\begin_layout Standard

\emph on
insert into mytable_count select count(*) from mytable;
\end_layout

\begin_layout Standard

\emph on
commit;
\end_layout

\begin_layout Standard
Here, we do everything in a single transaction so that no data modifications
 by concurrent transactions can be 
\begin_inset Quotes eld
\end_inset

lost
\begin_inset Quotes erd
\end_inset

 due to race conditions.
 The down side is of course that all concurrent data modifications have
 to wait until the 
\emph on
select count(*) 
\emph default
is done.
 This provides us with a really fast alternative to 
\emph on
count(*)
\emph default
, but at the price of slowing down all data modifications on the table.
 Using a deferred constraint trigger will make sure that the lock on the
 row in 
\emph on
mytable_count
\emph default
 is held as short as possible to improve concurrency.
\end_layout

\end_deeper
\begin_layout Itemize
Database server cannot actively use SWAP!
\end_layout

\begin_layout Itemize

\series bold
Relational databases does not support inheritance.
 Except PostgreSQL - a table can inherit from zero or more other tables.
 
\series default
(see its 
\begin_inset CommandInset href
LatexCommand href
name "documentation"
target "https://www.postgresql.org/docs/current/tutorial-inheritance.html"
literal "false"

\end_inset

) Although inheritance is frequently useful, it has not been integrated
 with unique constraints or foreign keys, which limits its usefulness.
\end_layout

\begin_layout Itemize

\series bold
Use pure predicates.
 
\series default
For example, 
\emph on
name = 'Pavel' 
\emph default
is pure predicate, but 
\emph on
upper(name) = 'PAVEL' 
\emph default
is not and should be avoided.
 Indices are being used only with pure predicates.
\end_layout

\begin_layout Subsection
Inheritance
\end_layout

\begin_layout Itemize
In PostgreSQL, a table can inherit from zero or more other tables, and a
 query can reference either all rows of a table or all rows of a table plus
 all of its descendant tables.
 The latter behavior is the default.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create table cities ( name text, population float, altitude int );
\end_layout

\begin_layout Standard

\emph on
create table capitals ( state char(2) ) inherits (cities);
\end_layout

\end_deeper
\begin_layout Itemize
We can use 
\emph on
only
\emph default
 keyword with 
\emph on
select / insert / update / delete
\emph default
 statements.
 It indicates, that a query should apply only to a given table, not to any
 table below a given one in the inheritance hierarchy: 
\emph on
select name, altitude from only cities where altitude > 500;
\end_layout

\begin_layout Itemize
To specify, that descendant tables are included, we can use 
\emph on
'*'
\emph default
: 
\emph on
select name, altitude from cities* where altitude > 500; 
\emph default
But this behavior is always the default, so we don't have to write 
\emph on
*
\emph default
 here.
\end_layout

\begin_layout Itemize

\series bold
All check constraints and not-null constraints on a parent table are automatical
ly inherited
\series default
 by its children, unless explicitly specified otherwise with 
\emph on
no inherit
\emph default
 clauses.
 Other types of constraints
\series bold
 (unique, primary key, and foreign key constraints) are not inherited.
\end_layout

\begin_layout Itemize

\series bold
A serious limitation
\series default
 of the inheritance feature is that 
\series bold
indexes (including unique constraints) and foreign key constraints only
 apply to single tables, not to their inheritance children.
\end_layout

\begin_layout Subsection
Security
\end_layout

\begin_layout Itemize
Having more database accounts is a good thing.
 Each role must have access only to such data, that needs for its work.
 Application user cannot own any database objects - tables, functions, and
 so on.
\end_layout

\begin_layout Itemize
It is practical to have 1 account that owns all database objects.
 This account is never used from any public application.
 Password is never stored in plaintext, but maybe in some encrypted vault.
\end_layout

\begin_layout Itemize
For changing a way of database access, see file 
\emph on
pg_hba.conf
\emph default
.
\end_layout

\begin_layout Subsection
Monitoring itself
\end_layout

\begin_layout Itemize
PostgreSQL log is stored in 
\emph on
/var/log/postgresql/postgresql-10-main.log 
\emph default
(for example).This is the only place where you can find all the details about
 query instances - for example about deadlocked queries.
 If you are missing info about specific queries found in other reports,
 have a look into this log for details.
\end_layout

\begin_layout Itemize
Queries taking more than 10/30 minutes to execute.
\end_layout

\begin_layout Itemize
Monitoring of IO load.
 Number of IO operations per second, intensity of write/read per second,
 and so on.
\end_layout

\begin_layout Itemize
Disks utilization.
 It is recommended to have at least 30-50% of free space.
\end_layout

\begin_layout Itemize
Number of connections to a database - active, non-active, waiting for lock,
 with open transactions.
 This tells a lot about the design of an application itself.
 Application should release and close these connections, and finish transactions.
\end_layout

\begin_layout Itemize
Long running (idle) transactions.
\end_layout

\begin_layout Itemize
Commit ratio.
\end_layout

\begin_layout Itemize
Cache hit ratio.
\end_layout

\begin_layout Itemize
Log checking - deadlocks, disconnected clients, too many connections from
 clients, failed login attempts.
\end_layout

\begin_layout Itemize
Table and index bloat.
\end_layout

\begin_layout Subsubsection

\emph on
pgBadger
\end_layout

\begin_layout Itemize
Tool for statistical PostgreSQL log processing.
 It requires proper logging configuration on PostgreSQL side - line format,
 what to log, and so on.
 For example, log only queries that take more than 10ms (probably a quite
 small portion of all queries, but this can still produces a gigabits of
 logs weekly).
\end_layout

\begin_layout Itemize
Interesting statistics:
\end_layout

\begin_deeper
\begin_layout Itemize
Overview - general activity: total numbers, read:write ratio, ...
\end_layout

\begin_layout Itemize
Connections - if some tool is supposed to be connected once, and has hundreds
 of re-connections, there might be a problem with the tool or network connection.
\end_layout

\begin_layout Itemize
Temporary files - size, number, queries generating the most or the biggest
 temporary files.
\end_layout

\begin_layout Itemize
Locks - types, waiting queries.
\end_layout

\begin_layout Itemize
Queries - by type, user, and so on.
\end_layout

\begin_layout Itemize
Events - such as the most frequent errors
\end_layout

\end_deeper
\begin_layout Subsubsection

\emph on
pg_stat_statements
\end_layout

\begin_layout Itemize
Statistics about generalized form of each query.
 The same queries, that differ only in parameters, are counted as one.
 There is no limit of 10ms like for 
\emph on
pgBadger
\emph default
.
\end_layout

\begin_layout Itemize
This shows count, total time, min/max/mean time, rows returned, blocks scanned
 or written, temporary tables, and so on.
\end_layout

\begin_layout Itemize
Watch out for:
\end_layout

\begin_deeper
\begin_layout Itemize
Long/frequently running queries.
\end_layout

\begin_layout Itemize
Queries returning huge amounts of rows - are they filtered in application
 and the rest thrown away?
\end_layout

\begin_layout Itemize
Statements that have lots of cache misses.
\end_layout

\begin_layout Itemize
Statements that manipulate with temporary blocks.
\end_layout

\end_deeper
\begin_layout Itemize
Usage example.
 overview:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pga.rolname, pgd.datname, pgs.query, pgs.calls,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pgs.total_time, pgs.min_time, pgs.max_time, pgs.mean_time,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pgs.rows, pgs.temp_blks_read, pgs.temp_blks_written
\end_layout

\begin_layout Standard

\emph on
from
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_stat_statements pgs
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_database pgd on pgs.dbid=pgd.oid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_authid pga on pgs.userid = pga.oid
\end_layout

\begin_layout Standard

\emph on
order by total_time desc limit 15;
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
Another good example, 5 top queries:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select query, calls, total_time, rows, 100.0 * shared_blks_hit / nullif(shared_bl
ks_hit + shared_blks_read, 0) as hit_percent
\end_layout

\begin_layout Standard

\emph on
from pg_stat_statements order by total_time desc limit 5;
\end_layout

\end_deeper
\begin_layout Itemize
Info about specific query:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select * from pg_stat_statements
\end_layout

\begin_layout Standard

\emph on
where query = refresh materialized view some_view'
\end_layout

\end_deeper
\begin_layout Description
PgBouncer
\end_layout

\begin_layout Itemize
This tool creates a cache (pool) connection to PostgreSQL.
 One or more connections to a given database under a given user is called
 here as 
\emph on
pool.
 
\emph default
You can limit the max number of connections in a pool.
\end_layout

\begin_layout Itemize
There is a fictive database 
\emph on
pgbouncer 
\emph default
that allows a basic administration and monitoring.
\end_layout

\begin_layout Itemize
Once properly configured, you can use 
\emph on
pgbounce
\emph default
 database: 
\emph on
psql -U postgres -p 6432 pgbouncer -c "show stats"
\end_layout

\begin_layout Subsection
Helpful queries and SQL snippets
\end_layout

\begin_layout Itemize
Watching queries in real-time
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
psql> select pid, state, datname, usename, query_start, substring(query
 from 0 for 150) as query
\end_layout

\begin_layout Standard

\emph on
from pg_stat_activity
\series bold
 
\backslash
watch
\series default
 [check_period_in_secs]
\end_layout

\end_deeper
\begin_layout Itemize
Kill running queries (requires superuser access)
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
psql> select pg_cancel_backend(<PID>);
\end_layout

\begin_layout Standard

\emph on
psql> select pg_terminate_backend(<PID>); -- forcibly terminates the backend,
 use only if cancel is not enough
\end_layout

\end_deeper
\begin_layout Itemize
All databases and their sizes
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select * from pg_user;
\end_layout

\end_deeper
\begin_layout Itemize
Check the size (as in disk space) of each table
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select nspname || '.' || relname as "relation",
\end_layout

\begin_layout Standard

\emph on
pg_size_pretty(pg_total_relation_size(C.oid)) as "total_size"
\end_layout

\begin_layout Standard

\emph on
from pg_class C
\end_layout

\begin_layout Standard

\emph on
left join pg_namespace N on (N.oid = C.relnamespace)
\end_layout

\begin_layout Standard

\emph on
where nspname not in ('pg_catalog', 'information_schema')
\end_layout

\begin_layout Standard

\emph on
and C.relkind <> 'i'
\end_layout

\begin_layout Standard

\emph on
and nspname !~ '^pg_toast'
\end_layout

\begin_layout Standard

\emph on
order by pg_total_relation_size(C.oid) desc;
\end_layout

\end_deeper
\begin_layout Itemize
All tables and their size, with/without indices
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select datname, pg_size_pretty(pg_database_size(datname)) from pg_database
 order by pg_database_size(datname) desc;
\end_layout

\end_deeper
\begin_layout Itemize
Cache hit rates (should not be less than 0.99)
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select sum(heap_blks_read) as heap_read, sum(heap_blks_hit) as heap_hit,
 (sum(heap_blks_hit) - sum(heap_blks_read)) / sum(heap_blks_hit) as ratio
\end_layout

\begin_layout Standard

\emph on
from pg_statio_user_tables;
\end_layout

\end_deeper
\begin_layout Itemize
Table index usage rates (should not be less than 0.99)
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select relname, 100 * idx_scan / (seq_scan + idx_scan) percent_of_times_index_us
ed, n_live_tup rows_in_table
\end_layout

\begin_layout Standard

\emph on
from pg_stat_user_tables
\end_layout

\begin_layout Standard

\emph on
order by n_live_tup desc;
\end_layout

\end_deeper
\begin_layout Itemize
List the 20 biggest databases
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select d.datname as Name, pg_catalog.pg_get_userbyid(d.datdba) as Owner,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case when pg_catalog.has_database_privilege(d.datname, 'CONNECT')
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

then pg_catalog.pg_size_pretty(pg_catalog.pg_database_size(d.datname))
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

else 'No Access'
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

end as size
\end_layout

\begin_layout Standard

\emph on
from pg_catalog.pg_database d
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

order by
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case when pg_catalog.has_database_privilege(d.datname, 'CONNECT')
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

then pg_catalog.pg_database_size(d.datname)
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

else null
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

end desc -- nulls first
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

limit 20;
\end_layout

\end_deeper
\begin_layout Itemize
Kill running query
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select pg_cancel_backend(procpid);
\end_layout

\end_deeper
\begin_layout Itemize
Kill idle query
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select pg_terminate_backend(procpid);
\end_layout

\end_deeper
\begin_layout Itemize
List biggest tables
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

table_name, 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_size_pretty(table_size) as table_size, 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_size_pretty(indexes_size) as indexes_size, 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_size_pretty(total_size) as total_size 
\end_layout

\begin_layout Standard

\emph on
from (
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

table_name, 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_table_size(table_name) as table_size, 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_indexes_size(table_name) as indexes_size, 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_total_relation_size(table_name) as total_size
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from ( 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

select ('"' || table_schema || '"."' || table_name || '"') as table_name
 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from information_schema.tables 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

) as all_tables 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

order by total_size desc
\end_layout

\begin_layout Standard

\emph on
) as pretty_sizes;
\end_layout

\end_deeper
\begin_layout Itemize
List index size and usage
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

t.tablename,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

indexname,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

c.reltuples as num_rows,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_size_pretty(pg_relation_size(quote_ident(t.tablename)::text)) as table_size,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_size_pretty(pg_relation_size(quote_ident(indexrelname)::text)) as index_size,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

case when indisunique then 'y'
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

else 'n'
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

end as unique,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

idx_scan as number_of_scans,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

idx_tup_read as tuples_read,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

idx_tup_fetch as tuples_fetched
\end_layout

\begin_layout Standard

\emph on
from pg_tables t
\end_layout

\begin_layout Standard

\emph on
left outer join pg_class c on t.tablename=c.relname
\end_layout

\begin_layout Standard

\emph on
left outer join
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

( select c.relname as ctablename, ipg.relname as indexname, x.indnatts as number_of
_columns, idx_scan, idx_tup_read, idx_tup_fetch, indexrelname, indisunique
 from pg_index x
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_class c on c.oid = x.indrelid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_class ipg on ipg.oid = x.indexrelid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_stat_all_indexes psai on x.indexrelid = psai.indexrelid )
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

as foo
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

on t.tablename = foo.ctablename
\end_layout

\begin_layout Standard

\emph on
where t.schemaname='public'
\end_layout

\begin_layout Standard

\emph on
order by 1,2;
\end_layout

\end_deeper
\begin_layout Itemize
List locks
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

blocked_activity.datname as database,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

blocked_locks.pid as blocked_pid,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

blocking_locks.pid as blocking_pid,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

blocked_activity.usename as blocked_user,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

blocking_activity.usename as blocking_user,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

blocked_activity.query as blocked_statement,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

blocking_activity.query as current_statement_in_blocking_process,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

blocked_activity.application_name as blocked_application,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

blocking_activity.application_name as blocking_application
\end_layout

\begin_layout Standard

\emph on
from pg_catalog.pg_locks blocked_locks
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_catalog.pg_stat_activity blocked_activity on blocked_activity.pid
 = blocked_locks.pid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_catalog.pg_locks blocking_locks 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

on blocking_locks.locktype = blocked_locks.locktype
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and blocking_locks.database is not distinct from blocked_locks.database
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and blocking_locks.relation is not distinct from blocked_locks.relation
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and blocking_locks.page is not distinct from blocked_locks.page
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and blocking_locks.tuple is not distinct from blocked_locks.tuple
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and blocking_locks.virtualxid is not distinct from blocked_locks.virtualxid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and blocking_locks.transactionid is not distinct from blocked_locks.transactionid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and blocking_locks.classid is not distinct from blocked_locks.classid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and blocking_locks.objid is not distinct from blocked_locks.objid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and blocking_locks.objsubid is not distinct from blocked_locks.objsubid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and blocking_locks.pid != blocked_locks.pid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_catalog.pg_stat_activity blocking_activity 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

on blocking_activity.pid = blocking_locks.pid
\end_layout

\begin_layout Standard

\emph on
where
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

not blocked_locks.GRANTED;
\end_layout

\end_deeper
\begin_layout Itemize
Show unused indices
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select s.schemaname,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

s.relname as tablename,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

s.indexrelname as indexname,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_size_pretty(pg_relation_size(s.indexrelid)) as index_size
\end_layout

\begin_layout Standard

\emph on
from pg_catalog.pg_stat_user_indexes s
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_catalog.pg_index i on s.indexrelid = i.indexrelid
\end_layout

\begin_layout Standard

\emph on
where s.idx_scan = 0 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and 0 <>all (i.indkey) 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

and not exists 
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

(select 1 from pg_catalog.pg_constraint c
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

where c.conindid = s.indexrelid)
\end_layout

\begin_layout Standard

\emph on
order by pg_relation_size(s.indexrelid) desc;
\end_layout

\end_deeper
\begin_layout Itemize
Another version of the previous query:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select schemaname || '.' || relname as table,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

indexrelname as index,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

pg_size_pretty(pg_relation_size(i.indexrelid)) as index_size,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

idx_scan as index_scans
\end_layout

\begin_layout Standard

\emph on
from pg_stat_user_indexes ui
\end_layout

\begin_layout Standard

\emph on
join pg_index i on ui.indexrelid = i.indexrelid
\end_layout

\begin_layout Standard

\emph on
where not indisunique
\end_layout

\begin_layout Standard

\emph on
and idx_scan < 50
\end_layout

\begin_layout Standard

\emph on
and pg_relation_size(relid) > 5 * 8192
\end_layout

\begin_layout Standard

\emph on
order by pg_relation_size(i.indexrelid) / nullif(idx_scan, 0)
\end_layout

\begin_layout Standard

\emph on
desc nulls first, pg_relation_size(i.indexrelid) desc;
\end_layout

\end_deeper
\begin_layout Itemize
Show table bloat for current DB - you should call 
\emph on
vacuum full analyze verbose <table name>
\emph default
 for the bloated tables.
 If it reports that it cannot remove some rows, you must find the transactions
 that could potentially see the rows and wait for it to end or terminate
 it forcefully.
\end_layout

\begin_deeper
\begin_layout Standard
select schemaname, relname, n_live_tup, n_dead_tup, to_char(n_dead_tup::real/n_l
ive_tup::real*100, '990D99') as dead_to_live_ratio_percent from pg_stat_user_tab
les where n_dead_tup > 0 order by n_dead_tup desc;
\end_layout

\end_deeper
\begin_layout Itemize
Show most expensive queries - this shows queries that the database spent
 most time processing - those can be slow queries called just a few times
 or very fast queries called gazillion times.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select pga.rolname, pgd.datname, pgs.query, pgs.calls, pgs.total_time, pgs.min_time,
 pgs.max_time, pgs.mean_time, pgs.rows
\end_layout

\begin_layout Standard

\emph on
from pg_stat_statements pgs
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_database pgd on pgs.dbid=pgd.oid
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

join pg_authid pga on pgs.userid = pga.oid
\end_layout

\begin_layout Standard

\emph on
order by total_time desc
\end_layout

\begin_layout Standard

\emph on
limit 15;
\end_layout

\end_deeper
\begin_layout Itemize
List connected users
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select distinct usename from pg_stat_activity;
\end_layout

\end_deeper
\begin_layout Itemize
List all database users
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select * from pg_stat_activity where current_query not like '<%';
\end_layout

\end_deeper
\begin_layout Itemize
Count number of lines in a table
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
analyze verbose some_table;
\end_layout

\end_deeper
\begin_layout Itemize
Count dead tuples in all tables
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select relname, n_dead_tup, n_live_tup, case when n_live_tup > 0 then n_dead_tup
/n_live_tup else 0 end as ratio
\end_layout

\begin_layout Standard

\emph on
from pg_stat_all_tables
\end_layout

\begin_layout Standard

\emph on
order by ratio desc, n_dead_tup desc, n_live_tup desc;
\end_layout

\end_deeper
\begin_layout Itemize
Great query that checks for your query performance:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select query, calls, total_time, total_time / calls as time_per, stddev_time,
 rows, rows / calls as rows_per, 100.0 * shared_blks_hit / nullif(shared_blks_hit
 + shared_blks_read, 0) as hit_percent
\end_layout

\begin_layout Standard

\emph on
from pg_stat_statements
\end_layout

\begin_layout Standard

\emph on
where query not similar to '%pg_%' and calls > 500
\end_layout

\begin_layout Standard

\emph on
--order by calls
\end_layout

\begin_layout Standard

\emph on
--order by total_time
\end_layout

\begin_layout Standard

\emph on
order by time_per
\end_layout

\begin_layout Standard

\emph on
--order by rows_per
\end_layout

\begin_layout Standard

\emph on
desc limit 20;
\end_layout

\end_deeper
\begin_layout Itemize
Move some rows from one table into another:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
with moved_rows as ( delete from products where "date" >= '2010-10-01' and
 "date" < '2010-11-01' returning * )
\end_layout

\begin_layout Standard

\emph on
insert into products_log
\end_layout

\begin_layout Standard

\emph on
select * from moved_rows;
\end_layout

\end_deeper
\begin_layout Itemize
1-to-1 relationship
\end_layout

\begin_deeper
\begin_layout Itemize
It may help in splitting wide tables into several narrow.
 Where some columns are heavily read.
\end_layout

\begin_layout Itemize
We can implement this by using 
\emph on
deferrable 
\emph default
constraints.
 This controls whether the constraint can be deferred.
 A constraint that is not 
\emph on
deferrable
\emph default
 will be checked immediately after every command.
 Checking of constraints that are 
\emph on
deferrable
\emph default
 can be 
\series bold
postponed until the end of the transaction
\series default
 (using the 
\emph on
set constraints 
\emph default
command).
 
\emph on
Not deferrable 
\emph default
is the default.
 If a constraint is 
\emph on
deferrable
\emph default
, this clause specifies the default time to check the constraint.
 If the constraint is 
\emph on
initially immediate
\emph default
, it is checked after each statement.
 This is the default.
 If the constraint is 
\emph on
initially deferred
\emph default
, it is checked only at the end of the transaction.
 Currently, only 
\emph on
unique, primary key, exclude,
\emph default
 and 
\emph on
references
\emph default
 (foreign key)
\emph on
 
\emph default
constraints accept this clause
\emph on
.
 Not null 
\emph default
and
\emph on
 check 
\emph default
constraints are not deferrable.
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
create table profiles (
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

uid int8 not null primary key,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

payload jsonb not null
\end_layout

\begin_layout Standard

\emph on
);
\end_layout

\begin_layout Standard

\emph on
create table users (
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

uid int 8 not null primary key,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

uname text not null
\end_layout

\begin_layout Standard

\emph on
);
\end_layout

\begin_layout Standard

\emph on
alter table users
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

add foreign key (uid) references profiles (uid)
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

deferrable initially deferred;
\end_layout

\begin_layout Standard

\emph on
alter table profiles
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

add foreign key (uid) references users (uid)
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

deferrable initially deferred;
\end_layout

\end_deeper
\begin_layout Itemize

\series bold
Defer 
\series default
can be used when we want:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
footnote{
\backslash
url{https://begriffs.com/posts/2017-08-27-deferrable-sql-constraints.html}}
\end_layout

\end_inset


\end_layout

\begin_deeper
\begin_layout Itemize
Cyclic foreign keys - but these can be sometimes solved by using 
\emph on
CTE
\emph default
.
\end_layout

\begin_layout Itemize
Relocating items, one per group
\end_layout

\begin_layout Itemize
Renumbering a list
\end_layout

\begin_layout Standard
However, query planner has worse performance.
 And also, troubleshooting can be harder.
\end_layout

\end_deeper
\end_deeper
\begin_layout Itemize
Removal of duplicated records using 
\emph on
ctid
\emph default
 (this is suitable only for certain tasks, because it is basically a physical
 identifier of a record):
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
delete from people p where ctid <> (select ctid from people where firstname=p.fir
stname and surname=p.surname limit 1);
\end_layout

\end_deeper
\begin_layout Itemize
Your cache hit ratio tells you how often your data is served from in memory
 vs.
 having to go to disk.
 Serving from memory vs.
 going to disk will be orders of magnitude faster, thus the more you can
 keep in memory the better.
 Of course you could provision an instance with as much memory as you have
 data, but you don’t necessarily have to.
 Instead watching your cache hit ratio and ensuring it is at 99% is a good
 metric for proper performance.
 You can monitor your cache hit ratio with:
\end_layout

\begin_deeper
\begin_layout Standard

\emph on
select sum(heap_blks_read) as heap_read,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

sum(heap_blks_hit) as heap_hit,
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

sum(heap_blks_hit) / (sum(heap_blks_hit) + sum(heap_blks_read)) as ratio
\end_layout

\begin_layout Standard

\emph on
\begin_inset space ~
\end_inset


\begin_inset space ~
\end_inset

from pg_statio_user_tables;
\end_layout

\end_deeper
\end_body
\end_document
